<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CDN下访问源站ERR_TOO_MANY_REDIRECTS</title>
    <url>/posts/1221/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>源站（GitHub pages）使用了 CDN，浏览器访问提示重定向过多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XXX.XXX.XXX 将您重定向的次数过多。</span><br><span class="line">尝试清除 Cookie.</span><br><span class="line">ERR_TOO_MANY_REDIRECTS</span><br></pre></td></tr></table></figure>

<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>Github Pages 开启了 Enforce HTTPS，且 CDN 中回源协议为 HTTP。此时客户端无论通过哪种协议访问源站的 CDN 加速域名，CDN 都会以 HTTP 协议回源。而源站因为 Enforce HTTPS 的存在返回 301 永久重定向强制要求 CDN 重新以 HTTPS 访问，但 CDN 下次依旧会发送 HTTP 请求。以此往复，就会出现以下情况<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/0x7b/CDN/img/20201224161640.png" alt="image"></p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><ul>
<li>关闭源站强制 HTTPS 跳转功能</li>
<li>在 CDN 管理控制台配置回源协议为 HTTPS，或协议跟随（腾讯云，其他 CDN 厂商同理）</li>
</ul>
<p><a href="https://help.aliyun.com/knowledge_detail/148179.html" target="_blank" rel="noopener">参考连接</a></p>
]]></content>
      <categories>
        <category>博客维护</category>
      </categories>
      <tags>
        <tag>BUGs</tag>
      </tags>
  </entry>
  <entry>
    <title>CXF服务列表暴露引发的安全问题</title>
    <url>/posts/1222/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好大哥无聊在逛网站的时候意外发现了某厂商的 Server list，此服务文档中记录大量的 services。测试结果也不出所料发现了 N+1 的 SQL 注入、HQL 注入、未授权访问及 xxe 等漏洞打包。提交 SRC 之后也是拿到了不错的赏金，就决定写（shui）篇文章记录以下，同时学习一下关于 WebService 和接口安全的知识。</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="Web-Service-简介"><a href="#Web-Service-简介" class="headerlink" title="Web Service 简介"></a>Web Service 简介</h2><p>Web Service 是一种跨语言和跨平台的<strong>远程调用(RPC)技术</strong>[使用网络调用其他网站资源]<br>主要分为两种：<br>一、SOAP 型 WebService</p>
<blockquote>
<p>SOAP（Simple Object Access Protocol，简单对象访问协议）使用 WSDL 描述服务，用于在 Web Service 中把远程调用和返回封装成机器可读的 XML 数据，定义了传输消息的规则或标准（在这个规则下发送方和接受方都能清楚的知道对方所要表达的意思）</p>
</blockquote>
<p>二、REST 型 WebService</p>
<blockquote>
<p>REST (REpresentational State Transfort，表征性状态转移)  是 SOAP 的优化版，但他并不是一种协而是一种架构风格。它简化了服务的请求方法 大体与 http 一致即远程调用请求时不需再对数据进行封装，由 URL 决定资源，HTTP Method（GET POST PUT DELETE）决定操作。响应返回消息可以支持多种数据格式如 JSON、CSV、RSS。客户端可以选择自己易于解析的格式获得输出消息</p>
</blockquote>
<p>WSDL（Web Services Description Language, 网络服务描述语言）</p>
<blockquote>
<p>WSDL 是一种 XML 语言，用于正式描述 Web service。考虑 Web 服务的 WSDL 描述及其与客户端的 API 契约。WSDL 描述指定了 Web Service 的地址，允许的通信机制，接口和消息类型。简而言之，WSDL 描述提供了客户端使用 Web 服务所需的所有信息。他定义了一个服务的具体接口文档，相当于一个详细的使用手册。<br>有了 WSDL 之后，使用 Web Service 的过程就变为获得该服务的 WSDL 描述，根据 WSDL 构造一条格式化的 SOAP 请求发送给服务器，然后接收一条同样 SOAP 格式的应答，最后根据先前的 WSDL 解析数据。</p>
</blockquote>
<p>WADL（Web Application Description Language，网络应用描述语言）</p>
<blockquote>
<p>WADL 像是 WSDL 的 REST 版，用来描述 REST 接口。</p>
</blockquote>
<p>因为 WADL 的解析比较简单，由 base+path 定位资源路径，method 定义请求方法，request 元素中 param name 定义请求参数名和参数类型。需要注意的是 RESTful 型接口 GET 传单参直接用“/”拼接到资源路径后边而不用“?”，对于多参数一般用 post。这里给一张图帮助理解，后续不再过多介绍<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122130214.png#align=left&display=inline&height=614&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=1267&status=done&style=none&width=1267" alt=""></p>
<h2 id="WSDL-基本结构及解析"><a href="#WSDL-基本结构及解析" class="headerlink" title="WSDL 基本结构及解析"></a>WSDL 基本结构及解析</h2><p>一个 WSDL 文档通常包含有以下元素 definitions、types、message、portType、binding、service 元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">definitions - WSDL文档的根元素，用来提供命名空间</span><br><span class="line">types       - 数据类型(标签)定义的容器，里面使用schema定义了一些标签结构供message引用</span><br><span class="line">message     - 通信消息的数据结构的抽象类型化定义。引用types中定义的标签</span><br><span class="line">operation   - 对服务中所支持的操作的抽象描述，一个operation描述了一个访问入口的请求消息与响应消息对。</span><br><span class="line">portType    - 对于某个访问入口点类型所支持的操作的抽象集合，这些操作可以由一个或多个服务访问点来支持。</span><br><span class="line">binding     - 特定端口类型的具体协议和数据格式规范的绑定。</span><br><span class="line">service     - 相关服务访问点的集合</span><br><span class="line">port        - 定义为协议&#x2F;数据格式绑定与具体Web访问地址组合的单个服务访问点。</span><br></pre></td></tr></table></figure>

<p>以一个挖 SRC 进行信息收集时在某 HUB 发现的 SOAP Service 资产说明如何解析 WSDL<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122130338.png#align=left&display=inline&height=529&margin=%5Bobject%20Object%5D&originHeight=529&originWidth=1049&status=done&style=none&width=1049" alt=""><br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122205912.png#align=left&display=inline&height=151&margin=%5Bobject%20Object%5D&name=&originHeight=151&originWidth=1620&status=done&style=none&width=1620" alt=""><br>服务列表描述了 CheckIdentityService 模块中的一个操作<br>访问其 WSDL 文档<a href="http://osms.xxx.com/osms/services/checkIdentityService?wsdl，给出了这个模块的binding和service元素，具体定义了Web服务实现使用的Internet协议、编码方案以及Internet地址" target="_blank" rel="noopener">http://osms.xxx.com/osms/services/checkIdentityService?wsdl，给出了这个模块的binding和service元素，具体定义了Web服务实现使用的Internet协议、编码方案以及Internet地址</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wsdl:definitions</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:wsdl</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/"</span> <span class="attr">xmlns:tns</span>=<span class="string">"http://impl.server.order.services.wbs.osms.xx.com/"</span> <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/soap/"</span> <span class="attr">xmlns:ns2</span>=<span class="string">"http://schemas.xmlsoap.org/soap/http"</span> <span class="attr">xmlns:ns1</span>=<span class="string">"http://server.order.services.wbs.osms.xx.com/"</span> <span class="attr">name</span>=<span class="string">"CheckIdentityServiceImplService"</span> <span class="attr">targetNamespace</span>=<span class="string">"http://impl.server.order.services.wbs.osms.xx.com/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wsdl:import</span> <span class="attr">location</span>=<span class="string">"http://osms.xxx.com/osms/services/checkIdentityService?wsdl=CheckIdentityService.wsdl"</span> <span class="attr">namespace</span>=<span class="string">"http://server.order.services.wbs.osms.xx.com/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">wsdl:import</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wsdl:binding</span> <span class="attr">name</span>=<span class="string">"CheckIdentityServiceImplServiceSoapBinding"</span> <span class="attr">type</span>=<span class="string">"ns1:CheckIdentityService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">soap:binding</span> <span class="attr">style</span>=<span class="string">"document"</span> <span class="attr">transport</span>=<span class="string">"http://schemas.xmlsoap.org/soap/http"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">wsdl:operation</span> <span class="attr">name</span>=<span class="string">"checkIdentity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">soap:operation</span> <span class="attr">soapAction</span>=<span class="string">""</span> <span class="attr">style</span>=<span class="string">"document"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wsdl:input</span> <span class="attr">name</span>=<span class="string">"checkIdentity"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">soap:body</span> <span class="attr">use</span>=<span class="string">"literal"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">wsdl:input</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wsdl:output</span> <span class="attr">name</span>=<span class="string">"checkIdentityResponse"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">soap:body</span> <span class="attr">use</span>=<span class="string">"literal"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">wsdl:output</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">wsdl:operation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">wsdl:binding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wsdl:service</span> <span class="attr">name</span>=<span class="string">"CheckIdentityServiceImplService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">wsdl:port</span> <span class="attr">binding</span>=<span class="string">"tns:CheckIdentityServiceImplServiceSoapBinding"</span> <span class="attr">name</span>=<span class="string">"CheckIdentityServiceImplPort"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">soap:address</span> <span class="attr">location</span>=<span class="string">"http://osms.xxx.com/osms/services/checkIdentityService"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">wsdl:port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">wsdl:service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">wsdl:definitions</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122211002.png#align=left&display=inline&height=191&margin=%5Bobject%20Object%5D&name=&originHeight=191&originWidth=1798&status=done&style=none&width=1798" alt=""><br>在 WSDL 文档的第三行导入了外部文档，使得整个 WSDL 文档元素完整起来。不直接将文档的每个元素写到一起而用这种导入的方法是工程模块化导致的结果<br>扯（ke）点（pu）题（yi）外（xia）话，绝对不是为了凑字数，真的！！！</p>
<blockquote>
<p>模块化的优点： 1.便于多人协作开发，每个部分开发不会干扰其它地方 2.便于调试修改，因为模块独立，发现问题比较容易，修改一处，也不影响别处，利于前端性能优化 3.利于代码复用，小块的代码可以更方便拿到别的项目中不加或者稍加修改使用，提高可维护性 4.便于功能的扩充，因为软件各个部分是独立的，不需要理解整个软件就可以添加功能，特别适合二次开发。 5.解决了部分恼人的命名冲突以及烦琐的文件依赖<br>缺点： 1.系统分层，调用链会很长 2.模块间通信,模块间发送消息会很耗性能</p>
</blockquote>
<p>以下为 import 引入的外部文档<br><a href="http://osms.xxx.com/osms/services/checkIdentityService?wsdl=checkIdentityService" target="_blank" rel="noopener">http://osms.xxx.com/osms/services/checkIdentityService?wsdl=checkIdentityService</a><br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122211239.png#align=left&display=inline&height=324&margin=%5Bobject%20Object%5D&name=&originHeight=324&originWidth=1572&status=done&style=none&width=1572" alt=""></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wsdl:definitions</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:wsdl</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/"</span> <span class="attr">xmlns:ns1</span>=<span class="string">"http://server.order.services.wbs.osms.sf.com/"</span> <span class="attr">name</span>=<span class="string">"CheckIdentityService"</span> <span class="attr">targetNamespace</span>=<span class="string">"http://server.order.services.wbs.osms.xx.com/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wsdl:types</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:tns</span>=<span class="string">"http://server.order.services.wbs.osms.xx.com/"</span> <span class="attr">elementFormDefault</span>=<span class="string">"unqualified"</span> <span class="attr">targetNamespace</span>=<span class="string">"http://server.order.services.wbs.osms.xx.com/"</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"checkIdentity"</span> <span class="attr">type</span>=<span class="string">"tns:checkIdentity"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"checkIdentityResponse"</span> <span class="attr">type</span>=<span class="string">"tns:checkIdentityResponse"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:complexType</span> <span class="attr">name</span>=<span class="string">"checkIdentity"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">minOccurs</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"arg0"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">minOccurs</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"arg1"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">minOccurs</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"arg2"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:complexType</span> <span class="attr">name</span>=<span class="string">"checkIdentityResponse"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">minOccurs</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"Return"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">wsdl:types</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wsdl:message</span> <span class="attr">name</span>=<span class="string">"checkIdentityResponse"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">wsdl:part</span> <span class="attr">element</span>=<span class="string">"ns1:checkIdentityResponse"</span> <span class="attr">name</span>=<span class="string">"parameters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">wsdl:part</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">wsdl:message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wsdl:message</span> <span class="attr">name</span>=<span class="string">"checkIdentity"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">wsdl:part</span> <span class="attr">element</span>=<span class="string">"ns1:checkIdentity"</span> <span class="attr">name</span>=<span class="string">"parameters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">wsdl:part</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">wsdl:message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wsdl:portType</span> <span class="attr">name</span>=<span class="string">"CheckIdentityService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">wsdl:operation</span> <span class="attr">name</span>=<span class="string">"checkIdentity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wsdl:input</span> <span class="attr">message</span>=<span class="string">"ns1:checkIdentity"</span> <span class="attr">name</span>=<span class="string">"checkIdentity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">wsdl:input</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">wsdl:output</span> <span class="attr">message</span>=<span class="string">"ns1:checkIdentityResponse"</span> <span class="attr">name</span>=<span class="string">"checkIdentityResponse"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">wsdl:output</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">wsdl:operation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">wsdl:portType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">wsdl:definitions</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="definitions-元素"><a href="#definitions-元素" class="headerlink" title="definitions 元素"></a>definitions 元素</h3><p>这里不过多介绍，它是每个 WSDL 文档中的根元素，就用来提供命名空间的</p>
<h3 id="types-元素"><a href="#types-元素" class="headerlink" title="types 元素"></a>types 元素</h3><p>数据类型(标签)定义的容器，里面使用 schema 定义了一些标签结构供 message 引用<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122211938.png#align=left&display=inline&height=330&margin=%5Bobject%20Object%5D&name=&originHeight=330&originWidth=1855&status=done&style=none&width=1855" alt=""><br>上面是数据定义部分，该部分定义了两个元素，一个是 checkIdentity，一个是 checkIdentityResponse<br>       checkIdentity：定义了一个复杂类型，包含三个简单的字符串，将来用来描述操作的参数传入部分；<br>       checkIdentityResponse：定义了一个复杂类型，仅仅包含一个简单的字符串，将来用来描述操作的返回值；<br>        这里 checkIdentityResponse 是和 checkIdentity 相关的，checkIdentity 相对于一个方法，里面的 <code>name=&quot;arg0&quot; type=&quot;xs:string&quot;</code>是确定传入参数 arg 是 String 类型的，而 checkIdentityResponse 中的 <code>name=&quot;Return&quot; type=&quot;xs:string&quot;</code>是确定方法 checkIdentity（String name）的返回类型是 String 类型。</p>
<h3 id="message-元素"><a href="#message-元素" class="headerlink" title="message 元素"></a>message 元素</h3><p>通信消息的数据结构的抽象化类型定义。引用 types 中定义的标签<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212054.png#align=left&display=inline&height=109&margin=%5Bobject%20Object%5D&name=&originHeight=109&originWidth=693&status=done&style=none&width=693" alt=""><br>该部分是消息格式的抽象定义：定义了两个消息 checkIdentityResponse 和 checkIdentity：<br>checkIdentity：checkIdentity 操作的请求消息格式，由一个消息片段组成，名字为 parameters，元素是我们前面定义的 types 中的元素；<br>checkIdentityResponse：checkIdentity 操作的响应消息格式，由一个消息片段组成，名字为 parameters，元素是我们前面定义的 types 中的元素；<br>　　如果采用 RPC 样式的消息传递，只需要将文档中的 element 元素修改为 type 即可。</p>
<h3 id="portType-元素"><a href="#portType-元素" class="headerlink" title="portType 元素"></a>portType 元素</h3><p>portType 元素定义了 Web 服务的抽象接口。该接口有点类似 Java 的接口，都是定义了一个抽象类型和方法，没有定义实现。在 WDSL 中，portType 元素是由 binding 和 service 元素来实现的，这两个元素用来说明 Web 服务实现使用的 Internet 协议、编码方案以及 Internet 地址。<br>一个 portType 中可以定义多个 operation，一个 operation 可以看作是一个方法，本文中 WSDL 文档的定义：<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212124.png#align=left&display=inline&height=112&margin=%5Bobject%20Object%5D&name=&originHeight=112&originWidth=810&status=done&style=none&width=810" alt=""><br>portType 定义了服务调用模式的类型，这里包含一个 checkIdentity 方法，同时包含 input 和 output 表明该操作是一个请求/响应模式，请求消息是前面定义的 checkIdentity，响应消息是前面定义的 scheckIdentityResponse。input 表示传递到 Web 服务的有效负载，output 消息表示传递给客户的有效负载。</p>
<h3 id="binding-元素"><a href="#binding-元素" class="headerlink" title="binding 元素"></a>binding 元素</h3><p>binding 元素将一个抽象 portType 映射到一组具体协议（SOAP 和 HTTP）、消息传递样式、编码样式。通常 binding 元素与协议专有的元素合在一起使用，本文中的例子：<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212149.png#align=left&display=inline&height=218&margin=%5Bobject%20Object%5D&name=&originHeight=218&originWidth=814&status=done&style=none&width=814" alt=""><br>binding 描述 Web Services 的通信协议。 <a href="soap:binding/">soap:binding/</a>描述使用 SOAP 协议，binding 还描述 Web Services 的方法、输入、输出。其描述了如何通过 SOAP/HTTP 来访问按照前面描述的访问入口点类型部署的访问入口。规定了在具体 SOAP 调用时，应当使用的 soapAction 是””。具体的使用需要参考特定协议定义的元素。</p>
<h3 id="service-元素"><a href="#service-元素" class="headerlink" title="service 元素"></a>service 元素</h3><p>service 元素包含一个或者多个 port 元素，其中每个 port 元素表示一个不同的 Web 服务。<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212221.png#align=left&display=inline&height=94&margin=%5Bobject%20Object%5D&name=&originHeight=94&originWidth=887&status=done&style=none&width=887" alt=""><br>首先这里<code>service</code>标签描述了服务名称<code>CheckIdentityServiceImp1Service</code>,<code>port name</code>描述了可以支持 soap1.1 协议,然后提供了该服务的访问地址(EndPoint)。</p>
<h3 id="手工构造-SOAP-请求包"><a href="#手工构造-SOAP-请求包" class="headerlink" title="手工构造 SOAP 请求包"></a>手工构造 SOAP 请求包</h3><p>以 SOAP1.1 协议为例<br>PS：SOAP1.1 和 SOAP1.2 协议的区别移步<a href="https://www.cnblogs.com/yefengmeander/p/4176771.html" target="_blank" rel="noopener">https://www.cnblogs.com/yefengmeander/p/4176771.html</a><br>SOAP 协议请求的一般格式为</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/osms/services/checkIdentityService</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: text/plain, */*; q=0.01</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36</span><br><span class="line"><span class="attribute">X-Requested-With</span>: XMLHttpRequest</span><br><span class="line"><span class="attribute">Referer</span>: http://osms.xxx.com/osms/services/checkIdentityService?wsdl=CheckIdentityService.wsdl</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Cookie</span>: xxx=xxx</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">SOAPAction:</span></span><br><span class="line"><span class="attribute">Content-Type</span>: text/xml;charset=UTF-8</span><br><span class="line"><span class="attribute">Host</span>: osms.xxx.com</span><br><span class="line"><span class="attribute">Content-Length</span>: 472</span><br><span class="line"></span><br><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ser="http://server.order.services.wbs.osms.xx.com/"&gt;</span><br><span class="line">&lt;soapenv:Header&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body&gt;</span><br><span class="line">...</span><br><span class="line">  &lt;soapenv:Fault&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;/soapenv:Fault&gt;</span><br><span class="line">&lt;/soapenv:Body&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>一般我们构造的请求包需要改变的就是 Envelope 和 Body 部分，Header 部分默认不变，Fault 部分可缺省。其中<a href="soapenv:Envelope/">soapenv:Envelope/</a>定义了使用的命名空间和编码格式，Body 部分包含请求正文是我们真正需要关注的。<br>如下图根据 types 元素中 complexType 输入参数的描述将对应值填入 body 部分即可<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212246.png#align=left&display=inline&height=561&margin=%5Bobject%20Object%5D&name=&originHeight=561&originWidth=1202&status=done&style=none&width=1202" alt=""></p>
<h1 id="挖掘过程简要记录"><a href="#挖掘过程简要记录" class="headerlink" title="挖掘过程简要记录"></a>挖掘过程简要记录</h1><p>首先拿到的是一个子域名 kbase.xxx.com<br>访问该域名，自动重定向到 main/login.jsp<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212306.png#align=left&display=inline&height=79&margin=%5Bobject%20Object%5D&name=&originHeight=79&originWidth=204&status=done&style=none&width=204" alt=""><br>直觉告诉我这个站有东西。首先看了下端口，JS 没什么可利用的东西，尝试扫目录<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122133540.png#align=left&display=inline&height=983&margin=%5Bobject%20Object%5D&name=&originHeight=983&originWidth=1893&status=done&style=none&width=1893" alt=""><br>找到了一个 Apache CXF 的 Server list<br>用 burp 的 Wsdler 自动化解析 WSDL 生成接口请求示例，然后手工测试 WebService。测试过程和平常的测试过程基本一致只不过换了一种数据格式传递 payload，在这里是以 XML 形式进行漏洞探测<br>本文重点不是在挖掘漏洞上故对具体测试过程省略处理，随便上两张图撑撑场子<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212324.png#align=left&display=inline&height=714&margin=%5Bobject%20Object%5D&name=&originHeight=714&originWidth=922&status=done&style=none&width=922" alt=""><br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212400.png#align=left&display=inline&height=583&margin=%5Bobject%20Object%5D&name=&originHeight=583&originWidth=1048&status=done&style=none&width=1048" alt=""><br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/0x7b/CDN/master/img/20210122212834.png#align=left&display=inline&height=843&margin=%5Bobject%20Object%5D&name=&originHeight=843&originWidth=1825&status=done&style=none&width=1825" alt=""><br>其实在 SOAP service 形式下存在的漏洞远不止这些，还可能存在任意文件读取、越权/未授权、远程代码执行、逻辑漏洞、注入漏洞、DOS 漏洞等具体要看后端 Web Method 的具体实现。<br>总结一下就是通过扫目录也可以是列目录漏洞等其他一些信息收集方法，找到一些接口，然后根据接口名定义和参数类型定义选择合适的攻击向量模糊测试。</p>
<h2 id="如何找到这些接口"><a href="#如何找到这些接口" class="headerlink" title="如何找到这些接口"></a>如何找到这些接口</h2><ol>
<li>搜索引擎搜索，包括但不限于 Google hacking、Fofa、Github 等</li>
<li>通过流量代理软件，正则匹配日志中有关接口的数据包</li>
<li>被动式扫描路径</li>
<li>其他有效信息收集手段</li>
</ol>
<h2 id="接口安全之我见"><a href="#接口安全之我见" class="headerlink" title="接口安全之我见"></a>接口安全之我见</h2><ol>
<li>对接口进行必要的身份验证，权限认证</li>
<li>严格控制用户输入</li>
<li>输出控制</li>
<li>接口访问限制</li>
<li>按照安全规范开发接口</li>
</ol>
<p>参考链接<br><a href="https://www.cnblogs.com/susanhonly/p/11929195.html" target="_blank" rel="noopener">https://www.cnblogs.com/susanhonly/p/11929195.html</a><br><a href="https://xz.aliyun.com/t/7541" target="_blank" rel="noopener">https://xz.aliyun.com/t/7541</a><br><a href="https://www.anquanke.com/post/id/85910" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85910</a><br><a href="https://www.cnblogs.com/zhaozhan/archive/2010/11/03/1868556.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaozhan/archive/2010/11/03/1868556.html</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>WebService</tag>
        <tag>接口安全</tag>
        <tag>CXF Server list</tag>
      </tags>
  </entry>
  <entry>
    <title>语雀Front-matter-demo</title>
    <url>/posts/1223/</url>
    <content><![CDATA[<p>这是一个模板,方便在语雀中快速编写符合 Yuque-Hexo 语法得文章,按照该模板即可保证文章格式。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 语雀Front-matter-demo</span><br><span class="line">cover:</span><br><span class="line">sticky: 2</span><br><span class="line">date: 2020-12-21</span><br><span class="line">updated:</span><br><span class="line">tags: [BUGs]</span><br><span class="line">categories: [博客维护]</span><br><span class="line">keywords: "重定向,ERROR,CDN,REDIRECTS"</span><br><span class="line">toc: True</span><br><span class="line">abbrlink:</span><br><span class="line">description: 这是一个模板,方便在语雀中快速编写符合Yuque-Hexo语法得文章,按照该模板即可保证文章格式。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>引入外部图片测试（语雀）<br><a href="https://cdn.jsdelivr.net/gh/0x7b/CDN/img/65033404_p0.jpg" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/jpeg/8398873/1608800119701-0aee20c6-8ea4-4ca2-959d-55ad5078c77c.jpeg#align=left&display=inline&height=1414&margin=%5Bobject%20Object%5D&originHeight=1414&originWidth=2000&size=0&status=done&style=none&width=2000" alt=""></a><br>目前看来还是会受防盗链的影响，<br><a href="https://github.com/x-cold/yuque-hexo/issues/41" target="_blank" rel="noopener">解决办法</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"no-referrer"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>可直接在语雀中添加，即可为这篇文章 no-referrer 属性<br>但这个解决方法也具有局限性：只能在 Chrome 浏览器中生效</p>
]]></content>
      <categories>
        <category>博客维护</category>
      </categories>
      <tags>
        <tag>BUGs</tag>
      </tags>
  </entry>
  <entry>
    <title>克隆账户</title>
    <url>/posts/1222/</url>
    <content><![CDATA[<h1 id="克隆账户原理"><a href="#克隆账户原理" class="headerlink" title="克隆账户原理"></a>克隆账户原理</h1><p>在 注册表中有两处保存了账号的 SID 相对标志符，一处是注册表 HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users 下的子键名，另一处是该子键的子项 F 的值。但微软犯了个不同步它们的错误，登录时用的是后者，查询时用前者。当用 Administrator 的 F 项覆盖其他账号的 F 项后，就造成了账号是管理员权限，但查询还是原来状态的情况，这就是所谓的克隆账号。<br>　　安全小知识：SID 也就是安全标识符（Security Identifiers），是标识用户、组和 计算机账户的唯一的号码。在第一次创建该账户时，将给网络上的每一个账户发布一个唯一的 SID。Windows 2000 中的内部进程将引用账户的 SID 而不是账户的用户或组名。如果创建账户，再删除账户，然后使用相同的   用户名创建另一个账户，则新账户将不具有授权给前一个账户的权力或权限，原因是该账户具有不同的 SID 号。 #</p>
<h1 id="克隆账户危害"><a href="#克隆账户危害" class="headerlink" title="克隆账户危害"></a>克隆账户危害</h1><p>当 系统用户一旦被克隆，配合终端服务，就等于向攻击者开启了一扇隐蔽的后门，让攻击者可以随时进入你的系统，这一扇门你看不到,因为它依靠的是微软的终端服务，并没有释放病毒文件，所以也不会被杀毒 软件所查杀。</p>
<h1 id="克隆账号的常用方法"><a href="#克隆账号的常用方法" class="headerlink" title="克隆账号的常用方法"></a>克隆账号的常用方法</h1><h2 id="①-使用工具克隆"><a href="#①-使用工具克隆" class="headerlink" title="① 使用工具克隆"></a>① 使用工具克隆</h2><p>首先创建一个用户，或者知道亦或者是能修改其他账户（如 guest）的密码<img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209253922-4dbf07b4-683a-4321-931b-7c10ef8af618.png#align=left&display=inline&height=28&margin=%5Bobject%20Object%5D&name=image.png&originHeight=40&originWidth=1059&size=8079&status=done&style=none&width=746" alt="image.png"><br>创建用户一般用的都是 net.exe，但有时候种种条件限制的时候我们可以使用 net1.exe。其实本质都是调用的 net1.exe。还不可以的话，我们可以用 copy 命令将 C:/Windows/System32/net1.exe 复制到其他地方并且改名。<br>如：copy C:/Windows/System32 1.exe 会把 C:/Windows/System32 复制到当前目录的 1.exe。就可以绕过一些只检测调用特定文件（如 C:/Windows/System32/net.exe）的 waf。<br><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209564784-aa91482b-d61f-49da-b17d-da99200e7191.png#align=left&display=inline&height=60&margin=%5Bobject%20Object%5D&name=image.png&originHeight=65&originWidth=810&size=8092&status=done&style=none&width=746" alt="image.png">然后就可以通过 1.exe 执行命令了<br><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209590521-889a74e3-0b43-4e4d-a28e-273fcde3c536.png#align=left&display=inline&height=487&margin=%5Bobject%20Object%5D&name=image.png&originHeight=505&originWidth=767&size=29304&status=done&style=none&width=740" alt="image.png"><br>上传 clone.exe，克隆账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: clone.exe UserName Password   &#x2F;Add</span><br><span class="line">Usage: clone.exe UserName ClonedUser &#x2F;Clone</span><br></pre></td></tr></table></figure>

<p>克隆完成<br><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209691323-567261e4-a5ef-4d54-b110-6c934cd79167.png#align=left&display=inline&height=144&margin=%5Bobject%20Object%5D&name=image.png&originHeight=156&originWidth=808&size=12216&status=done&style=none&width=746" alt="image.png"><br><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209709019-97fb9754-fe0a-41a1-bddf-efff42aaf40c.png#align=left&display=inline&height=180&margin=%5Bobject%20Object%5D&name=image.png&originHeight=187&originWidth=777&size=13487&status=done&style=none&width=746" alt="image.png"><br>可通过克隆账户登录目标主机，登录后依然是克隆对象的身份<br><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209735028-cfcfa613-45dc-43a1-a68e-790048dc3531.png#align=left&display=inline&height=428&margin=%5Bobject%20Object%5D&name=image.png&originHeight=439&originWidth=765&size=44721&status=done&style=none&width=746" alt="image.png"><br><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209765824-bfd6b96d-ec78-4b91-961f-91f18b1ad77b.png#align=left&display=inline&height=533&margin=%5Bobject%20Object%5D&name=image.png&originHeight=753&originWidth=1053&size=426381&status=done&style=none&width=746" alt="image.png"></p>
<h2 id="②-通过-powershell-的-ps-脚本克隆"><a href="#②-通过-powershell-的-ps-脚本克隆" class="headerlink" title="② 通过 powershell 的 ps 脚本克隆"></a>② 通过 powershell 的 ps 脚本克隆</h2><p><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209787259-797f4a9f-625f-4fff-98a0-55b4894b7cd0.png#align=left&display=inline&height=353&margin=%5Bobject%20Object%5D&name=image.png&originHeight=388&originWidth=821&size=31068&status=done&style=none&width=746" alt="image.png"></p>
<h2 id="③-手工修改注册表键值克隆"><a href="#③-手工修改注册表键值克隆" class="headerlink" title="③ 手工修改注册表键值克隆"></a>③ 手工修改注册表键值克隆</h2><h3 id="简单克隆"><a href="#简单克隆" class="headerlink" title="简单克隆"></a>简单克隆</h3><p>手动将 HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4 下的 F 键值复制到克隆账户的 F 值<br><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209802616-4c222ce1-cbd8-4640-bc64-8f538f95b1ae.png#align=left&display=inline&height=401&margin=%5Bobject%20Object%5D&name=image.png&originHeight=645&originWidth=1198&size=163440&status=done&style=none&width=744" alt="image.png"><br>复制方法有很多可以直接在注册表中编辑克隆账户的 F 键值。也可以导出注册表再编辑好了然后再导入。<br><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209814034-b829e18e-8901-408d-8547-79ed4a0b8d51.png#align=left&display=inline&height=423&margin=%5Bobject%20Object%5D&name=image.png&originHeight=820&originWidth=1446&size=369440&status=done&style=none&width=746" alt="image.png"><br>复制完保存，双击 000003EB.reg 导入就可以了（须先删除原克隆账户 walker$）<br>如下图可查看对应账户的SID<br><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209830671-949757e1-e65f-49e7-a39c-b4159d96ea26.png#align=left&display=inline&height=407&margin=%5Bobject%20Object%5D&name=image.png&originHeight=652&originWidth=1196&size=102921&status=done&style=none&width=746" alt="image.png"><br>但这样只是简单克隆即你克隆出来的账户和被克隆账户是两个不同的账户。quser一查询当前登录用户依然是克隆账户即walker$，即你只是克隆了 administrator 的权限。还有就是用命令“net localgroup administrators”还是可以看出 Guest 是管理员来，这就是我所说的隐蔽性比完全克隆要低些。</p>
<h3 id="完全克隆"><a href="#完全克隆" class="headerlink" title="完全克隆"></a>完全克隆</h3><p>完全克隆账户就是将 Administrator（默认 SID 是 500 即 0X1F4）的 F 键值和 V 键值都复制到克隆账户（walker$）的对应值里。同样可以直接在注册表修改，<br>也可以通过导出注册表修改再导入<br><img src= "/img/loading.gif" data-src="https://cdn.nlark.com/yuque/0/2020/png/8398873/1608209844695-773e62aa-227b-4e86-8e37-f4a78c19ad45.png#align=left&display=inline&height=450&margin=%5Bobject%20Object%5D&name=image.png&originHeight=550&originWidth=911&size=129655&status=done&style=none&width=746" alt="image.png"><br>直接将000001F4改为克隆账户的SID然后又导入（修改好后cmd删除克隆账户再导入），方便快捷。<br>这样的方法克隆出来的账户（walker$）和被克隆账户（administrator）实际上是 1 个账户，这样隐蔽性最高，除非用专业工具查看，否则在 net 和用户管理中，还有“net localgroup administrators”都看不出有什么问题来。还有最重要的一点，如果你登陆上去后，在“query user”和“终端服务管理器”里面你所登陆的用户上面显示的是“administrator”。</p>
]]></content>
      <categories>
        <category>后渗透</category>
      </categories>
      <tags>
        <tag>权限维持</tag>
        <tag>后门</tag>
      </tags>
  </entry>
</search>
